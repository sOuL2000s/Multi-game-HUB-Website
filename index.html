<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Multi Game Hub</title>
    <style>
        /* Global Styles */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a2a3a, #0a1a2a);
            color: #eee;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden; /* Prevent horizontal scroll on small screens */
        }
        .container {
            width: 90%;
            max-width: 1200px;
            background-color: #2b3b4b;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            margin: 20px 0;
            padding: 20px;
            text-align: center;
            overflow: hidden;
        }
        h1, h2, h3 {
            color: #4CAF50;
            margin-bottom: 20px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            margin: 10px;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        button:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .section {
            display: none; /* All game sections are hidden by default */
            padding: 20px;
            border-top: 1px solid #4a5a6a;
            margin-top: 20px;
            text-align: left;
        }
        .section.active {
            display: block;
        }
        .game-options {
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        .game-options button {
            background-color: #555;
            font-size: 1em;
            padding: 10px 20px;
        }
        .game-options button:hover {
            background-color: #666;
        }
        .game-board, .game-area {
            border: 2px solid #5a6a7a;
            background-color: #3b4b5b;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            min-height: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: auto; /* For game boards that might overflow */
        }
        .game-status {
            margin-top: 15px;
            font-size: 1.1em;
            color: #b0e0b0;
            min-height: 30px;
        }
        .player-info {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        .player-card {
            background-color: #3a4a5a;
            border-radius: 8px;
            padding: 10px 15px;
            margin: 10px;
            border: 1px solid #5a6a7a;
            min-width: 150px;
            text-align: center;
        }
        .player-card.current-player {
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        input[type="text"], input[type="number"] {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #5a6a7a;
            background-color: #1a2a3a;
            color: #eee;
            margin: 5px;
            width: 180px;
        }

        /* Home Page specific styles */
        #home-screen h2 {
            font-size: 2.5em;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        #home-screen p {
            font-size: 1.2em;
            color: #bbb;
            margin-bottom: 30px;
        }
        .game-selection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 25px;
            margin-top: 40px;
            padding: 0 20px;
        }
        .game-card {
            background-color: #3b4b5b;
            border-radius: 12px;
            padding: 25px;
            cursor: pointer;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            text-align: center;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            border: 1px solid #5a6a7a;
        }
        .game-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);
        }
        .game-card h3 {
            color: #4CAF50;
            margin-top: 0;
            font-size: 1.8em;
        }
        .game-card p {
            color: #ccc;
            font-size: 0.9em;
            min-height: 40px; /* Ensure consistent card height */
        }
        .game-card .icon {
            font-size: 3em;
            margin-bottom: 15px;
            color: #7ED957; /* A brighter green */
        }
        .game-card.ludo .icon { content: 'üé≤'; }
        .game-card.monopoly .icon { content: 'üí∞'; }
        .game-card.uno .icon { content: 'üÉè'; }
        .game-card.chess .icon { content: '‚ôüÔ∏è'; }


        /* Game Specific Styles */

        /* Ludo */
        #ludo-board {
            display: grid;
            grid-template-columns: repeat(15, 40px);
            grid-template-rows: repeat(15, 40px);
            gap: 1px;
            background-color: #000;
            border: 2px solid #5a6a7a;
            margin: 20px auto;
            position: relative;
        }
        .ludo-cell {
            width: 40px;
            height: 40px;
            background-color: #6a7a8a; /* Default path */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7em;
            position: relative;
        }
        /* Specific Ludo cell colors and areas for base */
        .ludo-cell.base-red { background-color: #e74c3c; }
        .ludo-cell.base-blue { background-color: #3498db; }
        .ludo-cell.base-green { background-color: #2ecc71; }
        .ludo-cell.base-yellow { background-color: #f1c40f; }

        .ludo-cell.path { background-color: #aaa; }
        .ludo-cell.safe { background-color: #888; }
        .ludo-cell.home-entry { background-color: #555; }
        .ludo-token {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            color: white;
            border: 2px solid rgba(0,0,0,0.3);
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
            transition: all 0.3s ease-in-out;
        }
        .ludo-token.red { background-color: #e74c3c; }
        .ludo-token.blue { background-color: #3498db; }
        .ludo-token.green { background-color: #2ecc71; }
        .ludo-token.yellow { background-color: #f1c40f; }
        .ludo-token.active {
            transform: scale(1.1);
            border-color: white;
            box-shadow: 0 0 10px rgba(255,255,255,0.7);
        }
        .ludo-token.selected {
            border-color: #4CAF50;
            box-shadow: 0 0 12px rgba(76, 175, 80, 0.9);
        }

        .ludo-dice {
            width: 60px;
            height: 60px;
            background-color: #eee;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5em;
            font-weight: bold;
            margin: 20px auto;
            border: 2px solid #5a6a7a;
            color: #333;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .ludo-dice:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
        }
        .ludo-dice:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        #ludo-player-homes {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        .ludo-player-home {
            background-color: #3a4a5a;
            border-radius: 8px;
            padding: 10px;
            margin: 5px;
            min-width: 120px;
            text-align: center;
            border: 1px solid #5a6a7a;
            position: relative;
        }
        .ludo-player-home.current-player {
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        .ludo-player-home .tokens-at-home {
            display: flex;
            justify-content: center;
            gap: 5px;
            margin-top: 5px;
        }
        .ludo-player-home .token-placeholder {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background-color: rgba(255,255,255,0.2);
            border: 1px dashed rgba(255,255,255,0.4);
            display: inline-block;
        }

        /* Monopoly */
        #monopoly-board {
            display: grid;
            grid-template-columns: 100px repeat(9, 60px) 100px;
            grid-template-rows: 100px repeat(9, 60px) 100px;
            width: 800px; /* (100 + 9*60 + 100) */
            height: 800px; /* (100 + 9*60 + 100) */
            border: 5px solid #333;
            margin: 20px auto;
            background-color: #cce7d0; /* Board background */
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        .monopoly-square {
            background-color: #fff;
            border: 1px solid #ccc;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            font-size: 0.6em;
            color: #333;
            text-align: center;
            padding: 2px;
            box-sizing: border-box;
            position: relative;
        }
        .monopoly-square.corner {
            width: 100px;
            height: 100px;
            font-size: 0.8em;
            padding: 5px;
            justify-content: center;
        }
        .monopoly-square.top, .monopoly-square.bottom {
            height: 100px;
            width: 60px;
            flex-direction: column-reverse;
        }
        .monopoly-square.left, .monopoly-square.right {
            width: 100px;
            height: 60px;
            flex-direction: row;
        }
        /* Specific corners */
        .square-go { background-color: #dff0d8; }
        .square-jail { background-color: #f2dede; }
        .square-free-parking { background-color: #d9edf7; }
        .square-go-to-jail { background-color: #fcf8e3; }

        .monopoly-square .color-bar {
            width: 100%;
            height: 15px;
            background-color: grey;
            position: absolute;
            top: 0;
            left: 0;
        }
        .monopoly-square.bottom .color-bar { bottom: 0; top: auto; }
        .monopoly-square.left .color-bar { left: 0; top: auto; width: 15px; height: 100%; }
        .monopoly-square.right .color-bar { right: 0; top: auto; width: 15px; height: 100%; }


        .color-dark-purple { background-color: #4C0050; } /* Dark Purple */
        .color-light-blue { background-color: #8be4ff; } /* Light Blue */
        .color-pink { background-color: #ff0073; }       /* Pink (Magenta) */
        .color-orange { background-color: #ff8c00; }     /* Orange */
        .color-red { background-color: #ff0000; }        /* Red */
        .color-yellow { background-color: #ffff00; }     /* Yellow */
        .color-green { background-color: #008000; }      /* Green */
        .color-dark-blue { background-color: #000080; }  /* Dark Blue */
        .color-railroad { background-color: #333; }      /* Railroad */
        .color-utility { background-color: #666; }       /* Utility */

        .monopoly-token {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: blue; /* Default */
            border: 2px solid white;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            color: white;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .monopoly-token.p1 { background-color: #e74c3c; } /* Red */
        .monopoly-token.p2 { background-color: #3498db; } /* Blue */
        .monopoly-token.p3 { background-color: #2ecc71; } /* Green */
        .monopoly-token.p4 { background-color: #f1c40f; } /* Yellow */

        #monopoly-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
        }
        #monopoly-dice-container {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        .monopoly-dice {
            width: 50px;
            height: 50px;
            background-color: #eee;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            font-weight: bold;
            color: #333;
            border: 1px solid #5a6a7a;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #monopoly-current-player-info {
            background-color: #3a4a5a;
            border-radius: 8px;
            padding: 10px 15px;
            margin-bottom: 15px;
            min-width: 250px;
            text-align: center;
            border: 1px solid #5a6a7a;
            box-shadow: 0 0 8px rgba(0,0,0,0.2);
        }
        #monopoly-current-player-info strong {
            color: #4CAF50;
            font-size: 1.2em;
        }
        #monopoly-player-holdings {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
        .monopoly-player-card {
            background-color: #3a4a5a;
            border-radius: 8px;
            padding: 10px 15px;
            border: 1px solid #5a6a7a;
            min-width: 200px;
            text-align: left;
        }
        .monopoly-player-card h4 {
            margin-top: 0;
            color: #b0e0b0;
            border-bottom: 1px dashed #5a6a7a;
            padding-bottom: 5px;
        }
        .monopoly-player-card ul {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 150px;
            overflow-y: auto;
        }
        .monopoly-player-card li {
            font-size: 0.9em;
            margin-bottom: 3px;
            color: #ccc;
        }
        .monopoly-action-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2b3b4b;
            border: 2px solid #4CAF50;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            max-width: 90%;
            text-align: center;
            font-size: 1.1em;
        }
        .monopoly-action-popup p {
            margin: 0;
            font-size: 1.2em;
            color: #eee;
        }
        .monopoly-action-popup button {
            margin: 5px;
            padding: 10px 20px;
            font-size: 1em;
        }

        /* Uno */
        #uno-game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }
        #uno-play-area {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            gap: 20px;
            min-height: 150px;
        }
        #uno-draw-pile, #uno-discard-pile {
            width: 100px;
            height: 150px;
            border: 2px dashed #5a6a7a;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(0,0,0,0.2);
            font-size: 0.9em;
            color: #bbb;
            position: relative;
        }
        #uno-discard-pile .uno-card {
            position: absolute;
            transform: rotate(randomAngle) scale(1); /* Dynamic rotation via JS */
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        #uno-draw-pile.active {
            cursor: pointer;
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        #uno-current-player-hand {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
            min-height: 180px;
            padding: 10px;
            border: 1px solid #4a5a6a;
            border-radius: 10px;
            background-color: #3b4b5b;
            max-width: 90%;
            overflow-x: auto;
        }
        .uno-card {
            width: 80px;
            height: 120px;
            background-color: #eee;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 1.8em;
            font-weight: bold;
            color: white;
            border: 1px solid #333;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: transform 0.1s ease-out, box-shadow 0.1s ease-out;
            position: relative;
            background-position: center;
            background-size: cover;
        }
        .uno-card.red { background-color: #e74c3c; }
        .uno-card.blue { background-color: #3498db; }
        .uno-card.green { background-color: #2ecc71; }
        .uno-card.yellow { background-color: #f1c40f; }
        .uno-card.wild { background-image: linear-gradient(135deg, #e74c3c, #3498db, #2ecc71, #f1c40f); }
        .uno-card.wild-draw-four { background-image: linear-gradient(135deg, #e74c3c, #3498db, #2ecc71, #f1c40f); }

        .uno-card.active {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
            border-color: #4CAF50;
        }
        .uno-card.disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .uno-card .card-value {
            z-index: 1; /* Ensure value is on top */
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .uno-card .card-color-indicator {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            text-transform: capitalize;
            color: rgba(255,255,255,0.4);
        }

        #uno-controls {
            margin-top: 20px;
            position: relative; /* For color picker positioning */
        }
        #uno-declare-button {
            background-color: #e67e22; /* Orange for Uno! */
        }
        #uno-declare-button.active {
            box-shadow: 0 0 15px rgba(230, 126, 34, 0.7);
            border: 2px solid #f39c12;
            animation: pulse-orange 1s infinite alternate;
        }
        @keyframes pulse-orange {
            from { box-shadow: 0 0 15px rgba(230, 126, 34, 0.7); }
            to { box-shadow: 0 0 25px rgba(230, 126, 34, 1); }
        }
        .uno-color-picker {
            position: absolute;
            background-color: #2b3b4b;
            border: 1px solid #4CAF50;
            border-radius: 8px;
            padding: 10px;
            display: none;
            flex-direction: column;
            gap: 5px;
            z-index: 100;
            left: 50%;
            transform: translateX(-50%);
            bottom: 100%; /* Position above controls */
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        .uno-color-picker button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin: 0;
            border: 2px solid transparent;
            font-size: 0; /* Hide text */
        }
        .uno-color-picker button:hover {
            border-color: #fff;
            transform: scale(1.1);
        }
        .uno-color-picker button.red { background-color: #e74c3c; }
        .uno-color-picker button.blue { background-color: #3498db; }
        .uno-color-picker button.green { background-color: #2ecc71; }
        .uno-color-picker button.yellow { background-color: #f1c40f; }

        /* Chess Game */
        #chess-board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            width: 480px; /* 8 * 60px */
            height: 480px; /* 8 * 60px */
            border: 4px solid #795548; /* Wood color border */
            margin: 20px auto;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }
        .chess-cell {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5em; /* For pieces */
            cursor: pointer;
            user-select: none;
            position: relative;
        }
        .chess-cell.light {
            background-color: #f0d9b5; /* Light square color */
        }
        .chess-cell.dark {
            background-color: #b58863; /* Dark square color */
        }
        .chess-cell.selected {
            background-color: #ffcc00; /* Selected piece highlight */
        }
        .chess-cell.highlight-move {
            background-color: #7ED957; /* Valid move highlight */
            border-radius: 50%; /* Make highlight a dot */
            opacity: 0.7;
            margin: 15px; /* Shrink to a dot */
            width: 30px;
            height: 30px;
        }
        .chess-cell.highlight-capture {
            box-shadow: inset 0 0 0 5px #e74c3c; /* Red border effect */
            border-radius: 5px; /* So it doesn't clip the piece too much */
        }
        .chess-cell .chess-piece {
            font-size: 1.5em;
            color: #333; /* Default for piece symbols */
            line-height: 1; /* Adjust vertical alignment */
            z-index: 1;
        }
        /* Custom colors for pieces if desired, otherwise standard black/white unicode */
        .chess-piece.white { color: #eee; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); }
        .chess-piece.black { color: #333; text-shadow: 1px 1px 2px rgba(255,255,255,0.5); }

        #chess-player-info {
            margin-top: 20px;
        }
        #chess-player-info strong {
            color: #4CAF50;
            font-size: 1.2em;
        }
        #chess-controls button {
            margin-top: 15px;
        }

        /* Lobby specific styles */
        #online-lobby-section {
            text-align: center;
        }
        #lobby-status {
            font-size: 1.2em;
            color: #b0e0b0;
            margin-bottom: 20px;
        }
        #player-name-input-group {
            margin-bottom: 20px;
        }
        #player-name-input-group label {
            margin-right: 10px;
        }
        #lobby-controls {
            margin-bottom: 30px;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        #create-game-form {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        #create-game-form select, #create-game-form input {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #5a6a7a;
            background-color: #1a2a3a;
            color: #eee;
        }
        #available-games {
            list-style: none;
            padding: 0;
            margin: 0 auto;
            max-width: 600px;
        }
        #available-games li {
            background-color: #3b4b5b;
            border: 1px solid #5a6a7a;
            border-radius: 8px;
            margin-bottom: 10px;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }
        #available-games li span {
            margin-right: 10px;
            color: #ccc;
        }
        #available-games li button {
            margin: 0;
            padding: 8px 15px;
            font-size: 0.9em;
        }
        #game-messages-container {
            margin-top: 20px;
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #5a6a7a;
            border-radius: 8px;
            padding: 10px;
            background-color: #1a2a3a;
            font-size: 0.9em;
            text-align: left;
        }
        #game-messages-container p {
            margin: 3px 0;
            color: #bbb;
        }
        .chat-message {
            color: #fff;
        }
        .status-message {
            color: #b0e0b0;
        }
        .error-message {
            color: #e74c3c;
        }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .container {
                width: 95%;
                padding: 15px;
            }
            h1 {
                font-size: 1.8em;
            }
            button {
                padding: 10px 20px;
                font-size: 1em;
            }
            .game-selection-grid {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 15px;
            }
            .game-card {
                padding: 20px;
            }
            .game-card h3 {
                font-size: 1.5em;
            }
            .game-card .icon {
                font-size: 2.5em;
            }

            /* Ludo */
            #ludo-board {
                grid-template-columns: repeat(15, 25px);
                grid-template-rows: repeat(15, 25px);
                width: auto;
                height: auto;
            }
            .ludo-cell {
                width: 25px;
                height: 25px;
            }
            .ludo-token {
                width: 20px;
                height: 20px;
                font-size: 0.7em;
            }
            .ludo-dice {
                width: 50px;
                height: 50px;
                font-size: 2em;
            }
            .ludo-player-home {
                min-width: 100px;
                padding: 5px;
                font-size: 0.9em;
            }
            .ludo-player-home h4 {
                font-size: 1em;
            }

            /* Monopoly */
            #monopoly-board {
                width: 100%;
                height: auto;
                grid-template-columns: 80px repeat(9, 40px) 80px;
                grid-template-rows: 80px repeat(9, 40px) 80px;
            }
            .monopoly-square {
                font-size: 0.5em;
            }
            .monopoly-square.corner {
                width: 80px;
                height: 80px;
            }
            .monopoly-square.top, .monopoly-square.bottom {
                height: 80px;
                width: 40px;
            }
            .monopoly-square.left, .monopoly-square.right {
                width: 80px;
                height: 40px;
            }
            .monopoly-token {
                width: 15px;
                height: 15px;
                font-size: 0.7em;
            }
            .monopoly-player-card {
                min-width: 150px;
            }

            /* Uno */
            .uno-card {
                width: 60px;
                height: 90px;
                font-size: 1.4em;
            }
            #uno-draw-pile, #uno-discard-pile {
                width: 80px;
                height: 120px;
            }
            #uno-current-player-hand {
                max-height: 120px;
                min-height: 120px;
            }

            /* Chess */
            #chess-board {
                width: 320px; /* 8 * 40px */
                height: 320px; /* 8 * 40px */
                grid-template-columns: repeat(8, 40px);
                grid-template-rows: repeat(8, 40px);
            }
            .chess-cell {
                width: 40px;
                height: 40px;
                font-size: 2em;
            }
            .chess-cell.highlight-move {
                margin: 10px; /* Adjust dot size */
                width: 20px;
                height: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Multiplayer Multi Game Hub</h1>
            <nav id="main-nav">
                <button onclick="showSection('home-screen')">Home</button>
                <button onclick="showSection('online-lobby-section')">Online Lobby</button>
            </nav>
        </header>

        <section id="home-screen" class="section active">
            <h2>Welcome to the Game Hub!</h2>
            <p>Select a game to play against AI or a friend (hot-seat).</p>

            <div class="game-selection-grid">
                <div class="game-card ludo" onclick="showGameSetup('ludo', 'local')">
                    <span class="icon">üé≤</span>
                    <h3>Ludo</h3>
                    <p>Race your tokens home in this classic board game.</p>
                </div>
                <div class="game-card monopoly" onclick="showGameSetup('monopoly', 'local')">
                    <span class="icon">üí∞</span>
                    <h3>Monopoly (Advanced Simplified)</h3>
                    <p>Buy, sell, and manage properties to bankrupt opponents.</p>
                </div>
                <div class="game-card uno" onclick="showGameSetup('uno', 'local')">
                    <span class="icon">üÉè</span>
                    <h3>Uno</h3>
                    <p>Match colors and numbers, play action cards!</p>
                </div>
                <div class="game-card chess" onclick="showGameSetup('chess', 'local')">
                    <span class="icon">‚ôüÔ∏è</span>
                    <h3>Chess (Simplified)</h3>
                    <p>Strategic board game of kings, queens, and pawns.</p>
                </div>
            </div>
            <p style="margin-top: 30px; font-size: 0.9em; color: #999;">
                <strong>Important Note for Local Play:</strong> "Human vs Human" modes are for **hot-seat play** on the same device. AI opponents are **basic and rule-based**. "Full feature" for complex games like Monopoly and Chess is heavily constrained by this single-file, front-end design, leading to significant simplifications (e.g., Monopoly still lacks trading/mortgaging/auctions/house-building; Chess lacks castling/en passant/full checkmate detection).
            </p>
        </section>

        <!-- Online Lobby Section -->
        <section id="online-lobby-section" class="section">
            <h2>Online Lobby</h2>
            <p id="lobby-status">Connecting to server...</p>

            <div id="player-name-input-group">
                <label for="my-player-name">Your Name:</label>
                <input type="text" id="my-player-name" placeholder="Enter your name">
                <button onclick="saveMyPlayerName()">Set Name</button>
            </div>

            <div id="lobby-controls">
                <div id="create-game-form">
                    <label for="create-game-type">Game:</label>
                    <select id="create-game-type">
                        <option value="ludo">Ludo</option>
                        <option value="monopoly">Monopoly</option>
                        <option value="uno">Uno</option>
                        <option value="chess">Chess</option>
                    </select>
                    <label for="create-game-max-players">Max Players:</label>
                    <input type="number" id="create-game-max-players" value="2" min="2" max="4">
                    <button onclick="createOnlineGame()">Create Game</button>
                </div>
            </div>

            <h3>Available Games</h3>
            <ul id="available-games">
                <!-- Games will be listed here by JavaScript -->
                <li>No games available. Create one!</li>
            </ul>

            <div id="game-messages-container">
                <h4>Game Log / Chat</h4>
                <div id="game-messages"></div>
                <input type="text" id="chat-input" placeholder="Type a message...">
                <button onclick="sendChatMessage()">Send</button>
            </div>
        </section>

        <!-- Ludo Section -->
        <section id="ludo-section" class="section">
            <h2>Ludo</h2>
            <!-- Player setup remains for LOCAL play only -->
            <div id="ludo-player-setup" class="player-setup">
                <h3>Player Setup (Local Play)</h3>
                <div class="player-setup-entry">
                    <label for="ludo-player1-type">Player 1 (Red):</label>
                    <input type="text" id="ludo-player1-name" value="Player 1">
                    <input type="radio" name="ludo-player1-mode" value="human" checked> Human
                    <input type="radio" name="ludo-player1-mode" value="bot"> Bot
                </div>
                <div class="player-setup-entry">
                    <label for="ludo-player2-type">Player 2 (Blue):</label>
                    <input type="text" id="ludo-player2-name" value="Player 2">
                    <input type="radio" name="ludo-player2-mode" value="human"> Human
                    <input type="radio" name="ludo-player2-mode" value="bot" checked> Bot
                </div>
                <div class="player-setup-entry">
                    <label for="ludo-player3-type">Player 3 (Green):</label>
                    <input type="text" id="ludo-player3-name" value="Player 3">
                    <input type="radio" name="ludo-player3-mode" value="human"> Human
                    <input type="radio" name="ludo-player3-mode" value="bot"> Bot
                </div>
                <div class="player-setup-entry">
                    <label for="ludo-player4-type">Player 4 (Yellow):</label>
                    <input type="text" id="ludo-player4-name" value="Player 4">
                    <input type="radio" name="ludo-player4-mode" value="human"> Human
                    <input type="radio" name="ludo-player4-mode" value="bot"> Bot
                </div>
                <button onclick="startGame('ludo', 'local')">Start Local Ludo Game</button>
            </div>

            <div id="ludo-game-area" class="game-area" style="display: none;">
                <p id="ludo-status" class="game-status">Welcome to Ludo!</p>
                <div id="ludo-player-homes"></div>
                <div id="ludo-board"></div>
                <div id="ludo-controls">
                    <div id="ludo-dice" onclick="sendLudoDiceRoll()">Roll Dice</div>
                    <button id="ludo-move-button" style="display: none;" onclick="sendLudoConfirmMove()">Confirm Move</button>
                    <button onclick="resetGame('ludo', currentPlayMode)">Reset Game</button>
                </div>
            </div>
        </section>

        <!-- Monopoly Section -->
        <section id="monopoly-section" class="section">
            <h2>Monopoly (Advanced Simplified)</h2>
             <!-- Player setup remains for LOCAL play only -->
            <div id="monopoly-player-setup" class="player-setup">
                <h3>Player Setup (Local Play) (2-4 Players)</h3>
                <div class="player-setup-entry">
                    <label for="monopoly-player1-type">Player 1 (Red):</label>
                    <input type="text" id="monopoly-player1-name" value="Player 1">
                    <input type="radio" name="monopoly-player1-mode" value="human" checked> Human
                    <input type="radio" name="monopoly-player1-mode" value="bot"> Bot
                </div>
                <div class="player-setup-entry">
                    <label for="monopoly-player2-type">Player 2 (Blue):</label>
                    <input type="text" id="monopoly-player2-name" value="Player 2">
                    <input type="radio" name="monopoly-player2-mode" value="human"> Human
                    <input type="radio" name="monopoly-player2-mode" value="bot" checked> Bot
                </div>
                <div class="player-setup-entry">
                    <label for="monopoly-player3-type">Player 3 (Green):</label>
                    <input type="text" id="monopoly-player3-name" value="Player 3">
                    <input type="radio" name="monopoly-player3-mode" value="human"> Human
                    <input type="radio" name="monopoly-player3-mode" value="bot"> Bot
                </div>
                <div class="player-setup-entry">
                    <label for="monopoly-player4-type">Player 4 (Yellow):</label>
                    <input type="text" id="monopoly-player4-name" value="Player 4">
                    <input type="radio" name="monopoly-player4-mode" value="human"> Human
                    <input type="radio" name="monopoly-player4-mode" value="bot"> Bot
                </div>
                <button onclick="startGame('monopoly', 'local')">Start Local Monopoly Game</button>
            </div>

            <div id="monopoly-game-area" class="game-area" style="display: none;">
                <p id="monopoly-status" class="game-status">Welcome to Monopoly!</p>
                <div id="monopoly-current-player-info">
                    Current Player: <strong id="monopoly-current-player-name"></strong> | Balance: <span id="monopoly-current-player-balance"></span>
                </div>
                <div id="monopoly-board"></div>
                <div id="monopoly-controls">
                    <div id="monopoly-dice-container">
                        <div class="monopoly-dice" id="monopoly-die1">1</div>
                        <div class="monopoly-dice" id="monopoly-die2">1</div>
                    </div>
                    <button id="monopoly-roll-dice-button" onclick="sendMonopolyDiceRoll()">Roll Dice</button>
                    <button id="monopoly-buy-button" style="display: none;" onclick="sendMonopolyBuyProperty()">Buy Property</button>
                    <button id="monopoly-end-turn-button" style="display: none;" onclick="sendMonopolyEndTurn()">End Turn</button>
                    <button onclick="resetGame('monopoly', currentPlayMode)">Reset Game</button>
                </div>
                <div id="monopoly-action-popup" class="monopoly-action-popup">
                    <p id="monopoly-popup-message"></p>
                    <div id="monopoly-popup-buttons"></div>
                </div>
                <div id="monopoly-player-holdings"></div>
            </div>
        </section>

        <!-- Uno Section -->
        <section id="uno-section" class="section">
            <h2>Uno</h2>
            <!-- Player setup remains for LOCAL play only -->
            <div id="uno-player-setup" class="player-setup">
                <h3>Player Setup (Local Play) (2-4 Players)</h3>
                <div class="player-setup-entry">
                    <label for="uno-player1-type">Player 1:</label>
                    <input type="text" id="uno-player1-name" value="Player 1">
                    <input type="radio" name="uno-player1-mode" value="human" checked> Human
                    <input type="radio" name="uno-player1-mode" value="bot"> Bot
                </div>
                <div class="player-setup-entry">
                    <label for="uno-player2-type">Player 2:</label>
                    <input type="text" id="uno-player2-name" value="Player 2">
                    <input type="radio" name="uno-player2-mode" value="human"> Human
                    <input type="radio" name="uno-player2-mode" value="bot" checked> Bot
                </div>
                 <div class="player-setup-entry">
                    <label for="uno-player3-type">Player 3:</label>
                    <input type="text" id="uno-player3-name" value="Player 3">
                    <input type="radio" name="uno-player3-mode" value="human"> Human
                    <input type="radio" name="uno-player3-mode" value="bot"> Bot
                </div>
                <div class="player-setup-entry">
                    <label for="uno-player4-type">Player 4:</label>
                    <input type="text" id="uno-player4-name" value="Player 4">
                    <input type="radio" name="uno-player4-mode" value="human"> Human
                    <input type="radio" name="uno-player4-mode" value="bot"> Bot
                </div>
                <button onclick="startGame('uno', 'local')">Start Local Uno Game</button>
            </div>

            <div id="uno-game-area" class="game-area" style="display: none;">
                <p id="uno-status" class="game-status">Welcome to Uno!</p>
                <div id="uno-play-area">
                    <div id="uno-draw-pile" onclick="sendUnoDrawCard()">Draw Pile</div>
                    <div id="uno-discard-pile">Discard Pile</div>
                </div>
                <div id="uno-player-info" class="player-info"></div>
                <div id="uno-current-player-hand"></div>
                <div id="uno-controls">
                    <button id="uno-declare-button" onclick="sendUnoDeclare()" style="display: none;">UNO!</button>
                    <button id="uno-end-draw-turn-button" style="display: none;" onclick="sendUnoEndTurn()">End Turn After Draw</button>
                    <div id="uno-color-picker" class="uno-color-picker">
                        <button class="red" onclick="sendUnoWildColor('red')">Red</button>
                        <button class="blue" onclick="sendUnoWildColor('blue')">Blue</button>
                        <button class="green" onclick="sendUnoWildColor('green')">Green</button>
                        <button class="yellow" onclick="sendUnoWildColor('yellow')">Yellow</button>
                    </div>
                    <button onclick="resetGame('uno', currentPlayMode)">Reset Game</button>
                </div>
            </div>
        </section>

        <!-- Chess Section -->
        <section id="chess-section" class="section">
            <h2>Chess (Simplified)</h2>
            <!-- Player setup remains for LOCAL play only -->
            <div id="chess-player-setup" class="player-setup">
                <h3>Player Setup (Local Play) (2 Players)</h3>
                <div class="player-setup-entry">
                    <label for="chess-player1-type">Player 1 (White):</label>
                    <input type="text" id="chess-player1-name" value="White Player">
                    <input type="radio" name="chess-player1-mode" value="human" checked> Human
                    <input type="radio" name="chess-player1-mode" value="bot"> Bot
                </div>
                <div class="player-setup-entry">
                    <label for="chess-player2-type">Player 2 (Black):</label>
                    <input type="text" id="chess-player2-name" value="Black Player">
                    <input type="radio" name="chess-player2-mode" value="human"> Human
                    <input type="radio" name="chess-player2-mode" value="bot" checked> Bot
                </div>
                <button onclick="startGame('chess', 'local')">Start Local Chess Game</button>
            </div>

            <div id="chess-game-area" class="game-area" style="display: none;">
                <p id="chess-status" class="game-status">Welcome to Chess!</p>
                <div id="chess-board"></div>
                <div id="chess-player-info">
                    Current Turn: <strong id="chess-current-player-name"></strong>
                </div>
                <div id="chess-controls">
                    <button onclick="resetGame('chess', currentPlayMode)">Reset Game</button>
                </div>
            </div>
        </section>

    </div>

    <script>
        // GLOBAL GAME STATE & UTILITIES
        const WS_URL = 'ws://localhost:8080'; // Your WebSocket server address
        let ws = null; // WebSocket connection
        let myClientId = null; // Client ID assigned by server
        let myPlayerName = localStorage.getItem('myPlayerName') || 'Guest'; // Stored player name
        let currentOnlineGameId = null; // ID of the game I'm currently in
        let currentOnlineGameType = null; // Type of game I'm currently in ('ludo', 'monopoly', etc.)
        let currentPlayMode = 'local'; // 'local' or 'online'

        // Centralized game state objects for local play
        let ludo = {};
        let monopoly = {};
        let uno = {};
        let chess = {};

        // DOM utility functions
        const DOM = {
            $: (selector) => document.querySelector(selector),
            $$: (selector) => document.querySelectorAll(selector),
            create: (tag, classes = [], content = '') => {
                const el = document.createElement(tag);
                if (classes.length) el.classList.add(...classes);
                if (content) el.innerHTML = content;
                return el;
            }
        };

        /**
         * Generic function to display messages in the game log/chat.
         * @param {string} message The message text.
         * @param {string} type Optional: 'status', 'error', 'chat' to apply different styles.
         */
        function displayGameMessage(message, type = 'status') {
            const messagesContainer = DOM.$('#game-messages');
            const p = DOM.create('p', [type], message);
            messagesContainer.appendChild(p);
            messagesContainer.scrollTop = messagesContainer.scrollHeight; // Scroll to bottom
            console.log(`[Game Message - ${type}]: ${message}`);
        }

        /**
         * Switches between different sections of the application.
         * @param {string} id The ID of the section to show (e.g., 'home-screen', 'online-lobby-section', 'ludo-section').
         */
        function showSection(id) {
            DOM.$$('.section').forEach(section => section.classList.remove('active'));
            DOM.$(`#${id}`).classList.add('active');
            
            // Special handling for game sections to show/hide player setup vs game area
            const gameSections = ['ludo-section', 'monopoly-section', 'uno-section', 'chess-section'];
            if (gameSections.includes(id)) {
                // For online games, player setup is hidden, game area shown immediately
                DOM.$(`#${id.replace('-section', '-player-setup')}`).style.display = 'none';
                DOM.$(`#${id.replace('-section', '-game-area')}`).style.display = 'flex';
            } else {
                 // For home or lobby, hide all game areas.
                gameSections.forEach(secId => {
                    DOM.$(`#${secId.replace('-section', '-game-area')}`).style.display = 'none';
                    // Show player setup forms for local games when returning to them.
                    DOM.$(`#${secId.replace('-section', '-player-setup')}`).style.display = 'block';
                });
            }
        }

        /**
         * Shows the game setup UI or starts a game based on play mode.
         * @param {string} gameId The ID of the game (e.g., 'ludo', 'monopoly').
         * @param {string} mode 'local' or 'online'.
         */
        function showGameSetup(gameId, mode) {
            currentPlayMode = mode;
            showSection(`${gameId}-section`); // Show the specific game's section
            DOM.$(`#${gameId}-game-area`).style.display = 'none'; // Hide game area initially
            DOM.$(`#${gameId}-player-setup`).style.display = 'block'; // Show setup form

            if (mode === 'local') {
                // For local play, the "Start Game" button will be on the setup screen.
            } else if (mode === 'online') {
                // For online play, setup is handled by the lobby and server.
                // Hide local player setup and immediately show game area
                DOM.$(`#${gameId}-player-setup`).style.display = 'none';
                DOM.$(`#${gameId}-game-area`).style.display = 'flex';
            }
        }

        /**
         * Starts a game. If 'local' mode, initializes the game immediately.
         * If 'online' mode, this function is mostly a placeholder as the server dictates game start.
         * @param {string} gameType 'ludo', 'monopoly', 'uno', 'chess'.
         * @param {string} mode 'local' or 'online'.
         */
        function startGame(gameType, mode) {
            currentPlayMode = mode;
            if (mode === 'local') {
                DOM.$(`#${gameType}-player-setup`).style.display = 'none';
                DOM.$(`#${gameType}-game-area`).style.display = 'flex';
                switch (gameType) {
                    case 'ludo': initLudoGame(); break;
                    case 'monopoly': initMonopolyGame(); break;
                    case 'uno': initUnoGame(); break;
                    case 'chess': initChessGame(); break;
                }
            } else { // Online mode - server is responsible for starting.
                displayGameMessage("Waiting for other players to join...", "status");
            }
        }

        /**
         * Resets a game to its initial state, either locally or online (by requesting server).
         * @param {string} gameType The type of game to reset.
         * @param {string} mode 'local' or 'online'.
         */
        function resetGame(gameType, mode) {
             if (confirm(`Are you sure you want to reset the ${gameType} game?`)) {
                if (mode === 'local') {
                    startGame(gameType, 'local'); // Re-initialize locally
                } else {
                    // In online mode, we'd send a request to the server to reset/end the game.
                    // For simplicity here, we'll just return to the lobby for now.
                    displayGameMessage("Online game reset is not fully implemented. Returning to lobby.", "status");
                    showSection('online-lobby-section');
                    currentOnlineGameId = null;
                    currentOnlineGameType = null;
                }
             }
        }

        // --- WebSocket Client Logic ---

        /**
         * Initializes the WebSocket connection to the server.
         */
        function initWebSocket() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                console.log("WebSocket already connected.");
                return;
            }

            ws = new WebSocket(WS_URL);

            ws.onopen = () => {
                displayGameMessage('Connected to game server.', 'status');
                DOM.$('#lobby-status').textContent = 'Connected to server.';
                // Request lobby update on connection
                ws.send(JSON.stringify({ type: 'GET_LOBBY_UPDATE' }));
            };

            ws.onmessage = event => {
                const message = JSON.parse(event.data);
                console.log('Received from server:', message);
                
                switch (message.type) {
                    case 'CONNECTED':
                        myClientId = message.clientId;
                        displayGameMessage(`Assigned Client ID: ${myClientId}`, 'status');
                        // Set default player name if not already set
                        if (!DOM.$('#my-player-name').value) {
                            DOM.$('#my-player-name').value = myPlayerName;
                        }
                        break;
                    case 'LOBBY_UPDATE':
                        updateLobbyUI(message.games);
                        break;
                    case 'GAME_CREATED':
                        currentOnlineGameId = message.gameId;
                        currentOnlineGameType = message.game.type;
                        displayGameMessage(`Game ${currentOnlineGameId} (${currentOnlineGameType}) created. Waiting for players...`, 'status');
                        showGameSectionForOnlinePlay(currentOnlineGameType);
                        // Update local game state with the initial state from server
                        updateLocalGameState(message.game.state[currentOnlineGameType]);
                        break;
                    case 'GAME_JOINED':
                        currentOnlineGameId = message.gameId || message.game.id; // Use game.id if gameId isn't top-level
                        currentOnlineGameType = message.game.type;
                        displayGameMessage(`Joined game ${currentOnlineGameId} (${currentOnlineGameType}).`, 'status');
                        showGameSectionForOnlinePlay(currentOnlineGameType);
                        // Update local game state with the initial state from server
                        updateLocalGameState(message.game.state[currentOnlineGameType]);
                        break;
                    case 'PLAYER_JOINED':
                        displayGameMessage(`${message.newPlayerId} joined game ${message.game.id}. Current players: ${Object.keys(message.game.players).length}/${message.game.maxPlayers}`, 'status');
                        // Re-render relevant UI to show new player (e.g., Monopoly holdings, Uno player cards)
                        updateLocalGameState(message.game.state[message.game.type]);
                        break;
                    case 'PLAYER_LEFT':
                        displayGameMessage(`${message.clientId} left game ${message.game.id}.`, 'status');
                        // Update player display
                        updateLocalGameState(message.game.state[message.game.type]);
                        if (Object.keys(message.game.players).length === 0) {
                            displayGameMessage(`Game ${message.game.id} disbanded. Returning to lobby.`, 'status');
                            currentOnlineGameId = null;
                            currentOnlineGameType = null;
                            showSection('online-lobby-section');
                        }
                        break;
                    case 'GAME_STARTED':
                        displayGameMessage(`Game ${message.gameId} has started!`, 'status');
                        // The server might send the initial state here too, or it's part of GAME_JOINED/CREATED
                        // Ensure local game state is updated.
                        updateLocalGameState(message.game.state[message.game.type]);
                        break;
                    case 'GAME_STATE_UPDATE':
                        // This is the main update for ongoing game play
                        if (message.gameId === currentOnlineGameId) {
                            // The server sends the entire game state for the current game
                            updateLocalGameState(message.state[currentOnlineGameType]);
                            // Also display any specific move message from server
                            if (message.moveResult && message.moveResult.message) {
                                updateGameStatusMessage(message.moveResult.message, currentOnlineGameType);
                            }
                            // Update player turn display based on server
                            updateCurrentPlayerTurn(message.currentPlayerTurnId, currentOnlineGameType);
                            // If game ended, transition UI
                            if (message.gameStatus === 'finished') {
                                displayGameMessage("Game finished! Returning to lobby.", 'status');
                                showSection('online-lobby-section');
                                currentOnlineGameId = null;
                                currentOnlineGameType = null;
                            }
                        }
                        break;
                    case 'CHAT_MESSAGE':
                        displayGameMessage(`[${message.sender}]: ${message.message}`, 'chat');
                        break;
                    case 'ERROR':
                        displayGameMessage(`Error: ${message.message}`, 'error');
                        break;
                    case 'OWNER_CHANGED':
                        displayGameMessage(`Game owner changed to ${message.newOwnerId}.`, 'status');
                        break;
                    default:
                        displayGameMessage(`Unknown message type: ${message.type}`, 'status');
                        break;
                }
            };

            ws.onclose = () => {
                displayGameMessage('Disconnected from game server.', 'error');
                DOM.$('#lobby-status').textContent = 'Disconnected. Try refreshing.';
                myClientId = null;
            };

            ws.onerror = error => {
                displayGameMessage(`WebSocket Error: ${error.message}`, 'error');
                DOM.$('#lobby-status').textContent = 'Connection error.';
            };
        }

        /**
         * Helper to show the correct game section for online play and hide setup.
         * @param {string} gameType The type of game ('ludo', 'monopoly', etc.).
         */
        function showGameSectionForOnlinePlay(gameType) {
            showSection(`${gameType}-section`);
            DOM.$(`#${gameType}-player-setup`).style.display = 'none';
            DOM.$(`#${gameType}-game-area`).style.display = 'flex';
        }

        /**
         * Updates the local game state object (ludo, monopoly, uno, chess) with the new state from the server
         * and triggers rendering.
         * @param {object} newState The new game state object for the active game.
         */
        function updateLocalGameState(newState) {
            if (!currentOnlineGameType) return;

            switch (currentOnlineGameType) {
                case 'ludo':
                    Object.assign(ludo, newState);
                    renderLudoBoard();
                    break;
                case 'monopoly':
                    Object.assign(monopoly, newState);
                    renderMonopolyBoard();
                    updateMonopolyPlayerHoldings();
                    // Special case for monopoly popup: if state is 'buying' or 'chance'/'chest', open popup for human
                    if (monopoly.state === 'buying' && monopoly.currentProperty && monopoly.currentProperty.owner === null && monopoly.currentProperty.price <= monopoly.players.find(p => p.id === myClientId)?.balance) {
                        if (myClientId === monopoly.players[monopoly.currentPlayerIndex].id) {
                             DOM.$('#monopoly-buy-button').style.display = 'block';
                             DOM.$('#monopoly-end-turn-button').style.display = 'none';
                        }
                    } else if (monopoly.state === 'chance' || monopoly.state === 'community_chest') {
                         if (myClientId === monopoly.players[monopoly.currentPlayerIndex].id) {
                            // This would be where you show the card to the specific player if it's their turn
                            // For simplicity, we just hide popup buttons if not their turn
                             showMonopolyPopup(monopoly.lastCardEffect.text, () => sendMonopolyCardActionDone());
                         } else {
                            hideMonopolyPopup(); // Hide for others
                         }
                    } else {
                        hideMonopolyPopup(); // Hide if not in specific popup state
                        DOM.$('#monopoly-buy-button').style.display = 'none';
                        if (myClientId === monopoly.players[monopoly.currentPlayerIndex].id && monopoly.state === 'post_roll') {
                            DOM.$('#monopoly-end-turn-button').style.display = 'block'; // Allow ending turn if player took action
                        } else {
                            DOM.$('#monopoly-end-turn-button').style.display = 'none';
                        }
                    }
                    break;
                case 'uno':
                    Object.assign(uno, newState);
                    renderUnoGame();
                    // Uno specific UI logic
                    if (uno.state === 'color_select' && myClientId === uno.players[uno.currentPlayerIndex].id) {
                        DOM.$('#uno-color-picker').style.display = 'flex';
                        updateUnoStatus(`${uno.players[uno.currentPlayerIndex].name}, select a new color for the Wild card.`);
                    } else {
                        DOM.$('#uno-color-picker').style.display = 'none';
                    }
                    if (myClientId === uno.players[uno.currentPlayerIndex].id && uno.state === 'await_draw_decision') {
                        DOM.$('#uno-end-draw-turn-button').style.display = 'block';
                    } else {
                        DOM.$('#uno-end-draw-turn-button').style.display = 'none';
                    }
                    break;
                case 'chess':
                    Object.assign(chess, newState);
                    renderChessBoard();
                    break;
            }
        }

        /**
         * Updates the game status message for the current online game.
         * @param {string} message The message to display.
         * @param {string} gameType The type of game.
         */
        function updateGameStatusMessage(message, gameType) {
            const statusEl = DOM.$(`#${gameType}-status`);
            if (statusEl) statusEl.textContent = message;
        }

        /**
         * Updates the current player turn display.
         * @param {string} currentPlayerId The client ID of the current player.
         * @param {string} gameType The type of game.
         */
        function updateCurrentPlayerTurn(currentPlayerId, gameType) {
            const playerInfoEl = DOM.$(`#${gameType}-current-player-name`);
            if (playerInfoEl) {
                const currentPlayer = (gameType === 'ludo' && ludo.players) ? ludo.players.find(p => p.id === currentPlayerId) :
                                      (gameType === 'monopoly' && monopoly.players) ? monopoly.players.find(p => p.id === currentPlayerId) :
                                      (gameType === 'uno' && uno.players) ? uno.players.find(p => p.id === currentPlayerId) :
                                      (gameType === 'chess' && chess.players) ? chess.players.find(p => p.id === currentPlayerId) : null;
                
                playerInfoEl.textContent = currentPlayer ? currentPlayer.name : 'Unknown Player';

                // General controls enable/disable based on turn
                const isMyTurn = (currentPlayerId === myClientId);
                // For Monopoly
                if (gameType === 'monopoly') {
                    DOM.$('#monopoly-roll-dice-button').disabled = !isMyTurn || monopoly.state !== 'await_roll';
                    // Other buttons (buy, end turn) are handled by specific game logic within updateLocalGameState
                }
                // For Ludo
                if (gameType === 'ludo') {
                    DOM.$('#ludo-dice').style.pointerEvents = isMyTurn && ludo.state === 'await_roll' ? 'auto' : 'none';
                    DOM.$('#ludo-dice').style.opacity = isMyTurn && ludo.state === 'await_roll' ? '1' : '0.6';
                    // Ludo move button handled by selectLudoToken
                }
                // For Uno
                if (gameType === 'uno') {
                    DOM.$('#uno-draw-pile').style.pointerEvents = isMyTurn && (uno.state === 'playing' || uno.state === 'await_draw_decision') ? 'auto' : 'none';
                    DOM.$('#uno-draw-pile').style.opacity = isMyTurn && (uno.state === 'playing' || uno.state === 'await_draw_decision') ? '1' : '0.6';
                    DOM.$('#uno-declare-button').disabled = !isMyTurn || uno.players.find(p => p.id === myClientId)?.hand.length !== 1 || uno.unoDeclared;
                    // Card playability handled by renderUnoGame and isValidUnoPlay
                }
                // For Chess
                if (gameType === 'chess') {
                    // Clicks on board handled by handleChessClick, which checks turn
                }
            }
        }


        // --- Lobby UI & Actions ---

        /**
         * Updates the list of available games in the online lobby.
         * @param {Array<object>} games An array of game objects from the server.
         */
        function updateLobbyUI(games) {
            const availableGamesList = DOM.$('#available-games');
            availableGamesList.innerHTML = ''; // Clear previous list

            if (games.length === 0) {
                availableGamesList.innerHTML = '<li>No games available. Create one!</li>';
                return;
            }

            games.forEach(game => {
                const li = DOM.create('li');
                li.innerHTML = `
                    <span>Game ID: ${game.id}</span>
                    <span>Type: ${game.type}</span>
                    <span>Owner: ${game.owner}</span>
                    <span>Players: ${game.currentPlayers}/${game.maxPlayers}</span>
                    <button onclick="joinOnlineGame('${game.id}')">Join Game</button>
                `;
                availableGamesList.appendChild(li);
            });
        }

        /**
         * Saves the player's chosen name to local storage and updates the UI.
         */
        function saveMyPlayerName() {
            const nameInput = DOM.$('#my-player-name');
            if (nameInput.value.trim()) {
                myPlayerName = nameInput.value.trim();
                localStorage.setItem('myPlayerName', myPlayerName);
                displayGameMessage(`Your name is set to: ${myPlayerName}`, 'status');
            } else {
                displayGameMessage("Please enter a valid player name.", 'error');
            }
        }

        /**
         * Sends a request to the server to create a new online game.
         */
        function createOnlineGame() {
            if (!myClientId) {
                displayGameMessage('Not connected to server. Please wait or refresh.', 'error');
                return;
            }
            if (!myPlayerName || myPlayerName === 'Guest') {
                displayGameMessage('Please set your player name first.', 'error');
                return;
            }

            const gameType = DOM.$('#create-game-type').value;
            const maxPlayers = parseInt(DOM.$('#create-game-max-players').value);

            ws.send(JSON.stringify({
                type: 'CREATE_GAME',
                gameType: gameType,
                playerName: myPlayerName,
                maxPlayers: maxPlayers
            }));
            displayGameMessage(`Requesting to create ${gameType} game...`, 'status');
        }

        /**
         * Sends a request to the server to join an existing online game.
         * @param {string} gameId The ID of the game to join.
         */
        function joinOnlineGame(gameId) {
            if (!myClientId) {
                displayGameMessage('Not connected to server. Please wait or refresh.', 'error');
                return;
            }
            if (!myPlayerName || myPlayerName === 'Guest') {
                displayGameMessage('Please set your player name first.', 'error');
                return;
            }
            ws.send(JSON.stringify({
                type: 'JOIN_GAME',
                gameId: gameId,
                playerName: myPlayerName
            }));
            displayGameMessage(`Requesting to join game ${gameId}...`, 'status');
        }

        /**
         * Sends a chat message to the current online game.
         */
        function sendChatMessage() {
            const chatInput = DOM.$('#chat-input');
            const message = chatInput.value.trim();
            if (message && currentOnlineGameId) {
                ws.send(JSON.stringify({
                    type: 'CHAT_MESSAGE',
                    gameId: currentOnlineGameId,
                    message: message
                }));
                chatInput.value = ''; // Clear input
            } else if (!currentOnlineGameId) {
                displayGameMessage('You must be in a game to chat.', 'error');
            }
        }

        // --- GAME-SPECIFIC ONLINE SENDERS (These replace direct game logic calls) ---
        // These functions send messages to the server instead of directly modifying `ludo`, `monopoly`, etc.

        // Ludo Senders
        function sendLudoDiceRoll() {
            if (currentPlayMode === 'online' && myClientId === ludo.players[ludo.currentPlayerIndex].id) {
                ws.send(JSON.stringify({
                    type: 'MAKE_MOVE',
                    gameId: currentOnlineGameId,
                    gameType: 'ludo',
                    payload: { action: 'rollDice' }
                }));
            } else if (currentPlayMode === 'local') {
                rollLudoDice(); // Call local logic
            } else {
                displayGameMessage("It's not your turn or you are not in an online game.", 'error');
            }
        }

        function sendLudoSelectToken(tokenEl) {
            if (currentPlayMode === 'online' && myClientId === ludo.players[ludo.currentPlayerIndex].id) {
                const tokenId = parseInt(tokenEl.dataset.tokenId);
                ws.send(JSON.stringify({
                    type: 'MAKE_MOVE',
                    gameId: currentOnlineGameId,
                    gameType: 'ludo',
                    payload: { action: 'selectToken', tokenId: tokenId }
                }));
                // Client-side visual selection, will be confirmed by server state update
                if (ludo.selectedToken) {
                    const prevSelectedEl = DOM.$(`[data-player-id="${ludo.selectedToken.playerId}"][data-token-id="${ludo.selectedToken.tokenId}"]`);
                    if (prevSelectedEl) prevSelectedEl.classList.remove('selected');
                }
                ludo.selectedToken = { playerId: myClientId, tokenId: tokenId };
                tokenEl.classList.add('selected');
                DOM.$('#ludo-move-button').style.display = 'block';
            } else if (currentPlayMode === 'local') {
                selectLudoToken(tokenEl); // Call local logic
            } else {
                displayGameMessage("It's not your turn or you are not in an online game.", 'error');
            }
        }

        function sendLudoConfirmMove() {
            if (currentPlayMode === 'online' && ludo.selectedToken && myClientId === ludo.players[ludo.currentPlayerIndex].id) {
                ws.send(JSON.stringify({
                    type: 'MAKE_MOVE',
                    gameId: currentOnlineGameId,
                    gameType: 'ludo',
                    payload: { action: 'confirmMove', tokenId: ludo.selectedToken.tokenId }
                }));
                ludo.selectedToken = null; // Clear client-side selection immediately
                DOM.$('#ludo-move-button').style.display = 'none';
            } else if (currentPlayMode === 'local' && ludo.selectedToken) {
                confirmLudoMove(); // Call local logic
            } else {
                displayGameMessage("No token selected or not your turn.", 'error');
            }
        }

        // Monopoly Senders
        function sendMonopolyDiceRoll() {
            if (currentPlayMode === 'online' && myClientId === monopoly.players[monopoly.currentPlayerIndex].id) {
                 ws.send(JSON.stringify({
                    type: 'MAKE_MOVE',
                    gameId: currentOnlineGameId,
                    gameType: 'monopoly',
                    payload: { action: 'rollDice' }
                }));
            } else if (currentPlayMode === 'local') {
                rollMonopolyDice();
            } else {
                displayGameMessage("It's not your turn or you are not in an online game.", 'error');
            }
        }
        function sendMonopolyBuyProperty() {
            if (currentPlayMode === 'online' && myClientId === monopoly.players[monopoly.currentPlayerIndex].id) {
                ws.send(JSON.stringify({
                    type: 'MAKE_MOVE',
                    gameId: currentOnlineGameId,
                    gameType: 'monopoly',
                    payload: { action: 'buyProperty' }
                }));
            } else if (currentPlayMode === 'local') {
                monopolyBuyProperty();
            } else {
                displayGameMessage("It's not your turn or you are not in an online game.", 'error');
            }
        }
        function sendMonopolyEndTurn() {
            if (currentPlayMode === 'online' && myClientId === monopoly.players[monopoly.currentPlayerIndex].id) {
                ws.send(JSON.stringify({
                    type: 'MAKE_MOVE',
                    gameId: currentOnlineGameId,
                    gameType: 'monopoly',
                    payload: { action: 'endTurn' }
                }));
            } else if (currentPlayMode === 'local') {
                monopolyEndTurn();
            } else {
                displayGameMessage("It's not your turn or you are not in an online game.", 'error');
            }
        }
        function sendMonopolyCardActionDone() { // For clicking OK on chance/community chest cards
            if (currentPlayMode === 'online' && myClientId === monopoly.players[monopoly.currentPlayerIndex].id) {
                 ws.send(JSON.stringify({
                    type: 'MAKE_MOVE',
                    gameId: currentOnlineGameId,
                    gameType: 'monopoly',
                    payload: { action: 'cardActionDone' }
                }));
                hideMonopolyPopup(); // Close local popup
            } else if (currentPlayMode === 'local') {
                hideMonopolyPopup();
                // Local version of cardActionDone should be integrated into local processMonopolyLandingPostCard or directly in card action
            }
        }


        // Uno Senders
        function sendUnoDrawCard() {
            if (currentPlayMode === 'online' && myClientId === uno.players[uno.currentPlayerIndex].id) {
                ws.send(JSON.stringify({
                    type: 'MAKE_MOVE',
                    gameId: currentOnlineGameId,
                    gameType: 'uno',
                    payload: { action: 'drawCard' }
                }));
            } else if (currentPlayMode === 'local') {
                DOM.$('#uno-draw-pile').onclick(); // Trigger local logic directly
            } else {
                displayGameMessage("It's not your turn or you are not in an online game.", 'error');
            }
        }
        function sendUnoPlayCard(cardToPlay, handIndex) {
            if (currentPlayMode === 'online' && myClientId === uno.players[uno.currentPlayerIndex].id) {
                ws.send(JSON.stringify({
                    type: 'MAKE_MOVE',
                    gameId: currentOnlineGameId,
                    gameType: 'uno',
                    payload: { action: 'playCard', card: cardToPlay, handIndex: handIndex }
                }));
            } else if (currentPlayMode === 'local') {
                playUnoCard(cardToPlay, handIndex);
            } else {
                displayGameMessage("It's not your turn or you are not in an online game.", 'error');
            }
        }
        function sendUnoWildColor(color) {
            if (currentPlayMode === 'online' && myClientId === uno.players[uno.currentPlayerIndex].id) {
                ws.send(JSON.stringify({
                    type: 'MAKE_MOVE',
                    gameId: currentOnlineGameId,
                    gameType: 'uno',
                    payload: { action: 'selectWildColor', color: color }
                }));
            } else if (currentPlayMode === 'local') {
                selectUnoWildColor(color);
            } else {
                displayGameMessage("It's not your turn or you are not in an online game.", 'error');
            }
        }
        function sendUnoDeclare() {
            if (currentPlayMode === 'online' && myClientId === uno.players[uno.currentPlayerIndex].id) {
                ws.send(JSON.stringify({
                    type: 'MAKE_MOVE',
                    gameId: currentOnlineGameId,
                    gameType: 'uno',
                    payload: { action: 'declareUno' }
                }));
            } else if (currentPlayMode === 'local') {
                declareUno();
            } else {
                displayGameMessage("It's not your turn or you are not in an online game.", 'error');
            }
        }
        function sendUnoEndTurn() { // For ending turn after draw, when player chose not to play drawn card
            if (currentPlayMode === 'online' && myClientId === uno.players[uno.currentPlayerIndex].id) {
                ws.send(JSON.stringify({
                    type: 'MAKE_MOVE',
                    gameId: currentOnlineGameId,
                    gameType: 'uno',
                    payload: { action: 'endTurn' }
                }));
            } else if (currentPlayMode === 'local') {
                nextUnoTurn(); // Directly calls next turn in local logic
            } else {
                displayGameMessage("It's not your turn or you are not in an online game.", 'error');
            }
        }


        // Chess Senders
        function sendChessMove(sr, sc, tr, tc, promoteTo = 'Q') {
            if (currentPlayMode === 'online' && myClientId === chess.players[chess.currentPlayerIndex].id) {
                ws.send(JSON.stringify({
                    type: 'MAKE_MOVE',
                    gameId: currentOnlineGameId,
                    gameType: 'chess',
                    payload: { action: 'movePiece', sr: sr, sc: sc, tr: tr, tc: tc, promoteTo: promoteTo }
                }));
            } else if (currentPlayMode === 'local') {
                moveChessPiece(sr, sc, tr, tc); // Directly calls local logic
            } else {
                displayGameMessage("It's not your turn or you are not in an online game.", 'error');
            }
        }
        // Chess handleChessClick will now call sendChessMove or local moveChessPiece
        function handleChessClickOnline({ r, c }) {
             if (currentPlayMode === 'online' && chess.state !== 'playing' || chess.players[chess.currentPlayerIndex].id !== myClientId) return;

            const pieceCode = chess.board[r][c];
            const currentPlayerColor = chess.players[chess.currentPlayerIndex].id[0];

            if (chess.selectedPiece) {
                const { r: sr, c: sc } = chess.selectedPiece;
                const legalMoves = getLegalChessMoves(sr, sc, chess.board);
                const isValidMove = legalMoves.some(move => move.r === r && move.c === c);

                if (isValidMove) {
                    const pieceType = getPieceType(chess.board[sr][sc]);
                    const pieceColor = getPieceColor(chess.board[sr][sc]);
                    if (pieceType === 'P' && ((pieceColor === 'w' && r === 0) || (pieceColor === 'b' && r === 7))) {
                        let promoteTo = null;
                        if (myClientId === chess.players[chess.currentPlayerIndex].id) {
                            do {
                                promoteTo = prompt("Pawn Promotion! Enter 'Q' for Queen.", 'Q');
                                if (promoteTo === null) { promoteTo = 'Q'; break; } // Default if cancel
                                promoteTo = promoteTo.toUpperCase();
                            } while (promoteTo !== 'Q'); // Only Queen for now
                        } else {
                            promoteTo = 'Q'; // Bot or non-active player defaults
                        }
                        sendChessMove(sr, sc, r, c, promoteTo);
                    } else {
                        sendChessMove(sr, sc, r, c);
                    }
                } else {
                    chess.selectedPiece = null;
                    renderChessBoard();
                    updateChessStatus(`${chess.players[chess.currentPlayerIndex].name}'s turn. Invalid move or deselected. Try again.`);
                    if (pieceCode && getPieceColor(pieceCode) === currentPlayerColor) {
                        chess.selectedPiece = { r, c, piece: pieceCode };
                        renderChessBoard();
                    }
                }
            } else {
                if (pieceCode && getPieceColor(pieceCode) === currentPlayerColor) {
                    chess.selectedPiece = { r, c, piece: pieceCode };
                    renderChessBoard();
                    updateChessStatus(`${chess.players[chess.currentPlayerIndex].name}'s turn. Selected ${getPieceType(pieceCode)} at (${r}, ${c}).`);
                } else if (pieceCode) {
                    updateChessStatus(`${chess.players[chess.currentPlayerIndex].name}'s turn. That's not your piece!`);
                } else {
                    updateChessStatus(`${chess.players[chess.currentPlayerIndex].name}'s turn. Select a piece to move.`);
                }
            }
        }
        // Override the local handleChessClick with the online version if we are in online mode
        // This is done by conditionally assigning the onclick handler
        // No, this needs to be directly in the cell creation.
        // During online mode, when rendering, the chess cell onclick handler needs to be `handleChessClickOnline`.
        // During local mode, it needs to be `handleChessClick`. This is handled in renderChessBoard() itself.


        // --- MAIN INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', () => {
            // Load player name from local storage
            DOM.$('#my-player-name').value = myPlayerName;
            
            // Initialize WebSocket connection
            initWebSocket();

            // Set up initial section (home or lobby)
            showSection('home-screen'); // Default to home, user can navigate to lobby

            // Initial setup for local play sections (ensure player setup forms are visible)
            DOM.$('#ludo-player-setup').style.display = 'block';
            DOM.$('#monopoly-player-setup').style.display = 'block';
            DOM.$('#uno-player-setup').style.display = 'block';
            DOM.$('#chess-player-setup').style.display = 'block';

            // Initial DOM modifications for online play in game sections
            // Modify chess.board's cell onclick assignment for online vs local
            // This needs to be dynamic in renderChessBoard. For now, it will use the currentPlayMode global.
        });


        // ===========================================================================================
        // LUDO GAME
        // ===========================================================================================
        const LUDO_BOARD_SIZE = 15;
        const LUDO_COLORS = ['red', 'blue', 'green', 'yellow'];
        const LUDO_TOKENS_PER_PLAYER = 4;

        // The `ludo` object is now updated by `updateLocalGameState` from the server for online play.
        // For local play, it's modified directly.
        // let ludo = { ... }; // Already declared globally

        const LUDO_PATH_COORDS = [
            // Red's actual start is {r:6,c:1} -- this is path index 0
            { r: 6, c: 1 }, { r: 6, c: 2 }, { r: 6, c: 3 }, { r: 6, c: 4 }, { r: 6, c: 5 }, // 0-4
            { r: 5, c: 6 }, { r: 4, c: 6 }, { r: 3, c: 6 }, { r: 2, c: 6 }, { r: 1, c: 6 }, { r: 0, c: 6 }, // 5-10
            { r: 0, c: 7 }, // 11
            { r: 0, c: 8 }, { r: 1, c: 8 }, { r: 2, c: 8 }, { r: 3, c: 8 }, { r: 4, c: 8 }, { r: 5, c: 8 }, // 12-17
            { r: 6, c: 9 }, { r: 6, c: 10 }, { r: 6, c: 11 }, { r: 6, c: 12 }, { r: 6, c: 13 }, { r: 6, c: 14 }, // 18-23
            { r: 7, c: 14 }, // 24
            { r: 8, c: 14 }, { r: 8, c: 13 }, { r: 8, c: 12 }, { r: 8, c: 11 }, { r: 8, c: 10 }, { r: 8, c: 9 }, // 25-30
            { r: 9, c: 8 }, { r: 10, c: 8 }, { r: 11, c: 8 }, { r: 12, c: 8 }, { r: 13, c: 8 }, { r: 14, c: 8 }, // 31-36
            { r: 14, c: 7 }, // 37
            { r: 14, c: 6 }, { r: 13, c: 6 }, { r: 12, c: 6 }, { r: 11, c: 6 }, { r: 10, c: 6 }, { r: 9, c: 6 }, // 38-43
            { r: 8, c: 5 }, { r: 8, c: 4 }, { r: 8, c: 3 }, { r: 8, c: 2 }, { r: 8, c: 1 }, { r: 8, c: 0 }, // 44-49
            { r: 7, c: 0 } // 50-51 (total 52 cells)
        ];

        // Global index on LUDO_PATH_COORDS where each player's token enters the main path
        const LUDO_PLAYER_START_INDICES = {
            red: 0,
            blue: 13,
            green: 26,
            yellow: 39
        };

        // Player-specific 'home' path before the finish center
        const LUDO_PLAYER_HOME_PATHS = {
            red: [{ r: 7, c: 1 }, { r: 7, c: 2 }, { r: 7, c: 3 }, { r: 7, c: 4 }, { r: 7, c: 5 }],
            blue: [{ r: 1, c: 7 }, { r: 2, c: 7 }, { r: 3, c: 7 }, { r: 4, c: 7 }, { r: 5, c: 7 }],
            green: [{ r: 13, c: 7 }, { r: 12, c: 7 }, { r: 11, c: 7 }, { r: 10, c: 7 }, { r: 9, c: 7 }],
            yellow: [{ r: 7, c: 13 }, { r: 7, c: 12 }, { r: 7, c: 11 }, { r: 7, c: 10 }, { r: 7, c: 9 }]
        };
        const LUDO_FINISH_CENTER = {r:7, c:7};
        
        // Global safe spots (star positions, and player entry points) - these are global board coordinates
        const LUDO_GLOBAL_SAFE_SPOTS_COORDS = [
            {r:6, c:1}, {r:1, c:7}, {r:7, c:13}, {r:13, c:7}, // Player's specific start cells
            {r:1, c:6}, {r:6, c:13}, {r:13, c:8}, {r:8, c:1}, // "Star" spots (simplified, common ones)
            {r:0, c:6}, {r:6, c:0}, {r:14, c:8}, {r:8, c:14}, // Other path "start" cells which are usually safe
            {r:0, c:8}, {r:8, c:0}, {r:14, c:6}, {r:6, c:14}
        ];

        /**
         * Converts a token's player-relative position to a global board coordinate {r, c}.
         * @param {string} playerColor The color of the player ('red', 'blue', etc.)
         * @param {number} position The token's current position (-1 for home, 0-51 for main path, 52-56 for home path, 57 for finished)
         * @returns {{r: number, c: number}|null} The global coordinate, or null if token is at home.
         */
        function getLudoVisualPosition(playerColor, position) {
            if (position === -1) return null; // Still at home base

            const mainPathLength = LUDO_PATH_COORDS.length;
            const homePathLength = LUDO_PLAYER_HOME_PATHS[playerColor].length;
            const finishPosition = mainPathLength + homePathLength; // This represents index 57 in conceptual path

            if (position < mainPathLength) { // On the main path (relative to player's start on the global path)
                const globalPathIndex = (LUDO_PLAYER_START_INDICES[playerColor] + position) % mainPathLength;
                return LUDO_PATH_COORDS[globalPathIndex];
            } else if (position >= mainPathLength && position < finishPosition) { // On player's home path
                const homePathIndex = position - mainPathLength;
                return LUDO_PLAYER_HOME_PATHS[playerColor][homePathIndex];
            } else if (position === finishPosition) { // Finished center
                return LUDO_FINISH_CENTER;
            }
            return null; // Should not happen
        }

        /**
         * Checks if a given global board coordinate {r, c} is a designated safe spot.
         * @param {number} r Row coordinate.
         * @param {number} c Column coordinate.
         * @returns {boolean} True if the spot is safe, false otherwise.
         */
        function isLudoGlobalSafeSpot(r, c) {
            return LUDO_GLOBAL_SAFE_SPOTS_COORDS.some(spot => spot.r === r && spot.c === c);
        }

        /**
         * Renders or re-renders the Ludo game board and player token positions.
         */
        function renderLudoBoard() {
            const boardEl = DOM.$('#ludo-board');
            boardEl.innerHTML = ''; // Clear previous board
            boardEl.style.gridTemplateColumns = `repeat(${LUDO_BOARD_SIZE}, 40px)`;
            boardEl.style.gridTemplateRows = `repeat(${LUDO_BOARD_SIZE}, 40px)`;

            // Create all cells first
            for (let r = 0; r < LUDO_BOARD_SIZE; r++) {
                for (let c = 0; c < LUDO_BOARD_SIZE; c++) {
                    const cell = DOM.create('div', ['ludo-cell']);
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    boardEl.appendChild(cell);
                }
            }

            // Highlight main path cells
            LUDO_PATH_COORDS.forEach(coord => {
                const cell = boardEl.querySelector(`[data-row="${coord.r}"][data-col="${coord.c}"]`);
                if (cell) cell.classList.add('path');
            });
            // Highlight player-specific home paths
            LUDO_COLORS.forEach(color => {
                LUDO_PLAYER_HOME_PATHS[color].forEach(coord => {
                    const cell = boardEl.querySelector(`[data-row="${coord.r}"][data-col="${coord.c}"]`);
                    if (cell) cell.classList.add('path', `home-entry`);
                });
            });
            // Highlight global safe spots
            LUDO_GLOBAL_SAFE_SPOTS_COORDS.forEach(coord => {
                const cell = boardEl.querySelector(`[data-row="${coord.r}"][data-col="${coord.c}"]`);
                if (cell) cell.classList.add('safe');
            });
            // Mark the center finish area
            const finishCell = boardEl.querySelector(`[data-row="${LUDO_FINISH_CENTER.r}"][data-col="${LUDO_FINISH_CENTER.c}"]`);
            if (finishCell) finishCell.innerHTML = 'üèÅ';


            // Render player home areas (tokens inside) and tokens on board
            const playerHomesEl = DOM.$('#ludo-player-homes');
            playerHomesEl.innerHTML = ''; // Clear previous homes

            ludo.players.forEach(player => {
                const playerHomeDiv = DOM.create('div', ['ludo-player-home', player.color]);
                playerHomeDiv.innerHTML = `<h4>${player.name} (${player.color})</h4>`;
                const tokensAtHomeDiv = DOM.create('div', ['tokens-at-home']);
                playerHomeDiv.appendChild(tokensAtHomeDiv);

                player.tokens.forEach(token => {
                    if (token.finished) { // Token is at the finish center
                        const finishCellEl = boardEl.querySelector(`[data-row="${LUDO_FINISH_CENTER.r}"][data-col="${LUDO_FINISH_CENTER.c}"]`);
                         if (finishCellEl) {
                            const tokenEl = DOM.create('div', ['ludo-token', player.color]);
                            tokenEl.dataset.playerId = player.id;
                            tokenEl.dataset.tokenId = token.id;
                            tokenEl.textContent = token.id + 1;
                            // Offset tokens inside the finish center for visibility
                            tokenEl.style.left = `${5 + (player.finishedTokens % 2 * 20)}px`;
                            tokenEl.style.top = `${5 + (Math.floor(player.finishedTokens / 2) * 20)}px`;
                            finishCellEl.appendChild(tokenEl);
                        }
                    } else if (token.position === -1) { // Token is still in its home base
                        const tokenEl = DOM.create('div', ['ludo-token', player.color]);
                        tokenEl.dataset.playerId = player.id;
                        tokenEl.dataset.tokenId = token.id;
                        tokenEl.textContent = token.id + 1;
                        tokenEl.onclick = () => sendLudoSelectToken(tokenEl); // Make clickable
                        tokensAtHomeDiv.appendChild(tokenEl);
                    } else { // Token is on main or home path
                        const visualPos = getLudoVisualPosition(player.color, token.position);
                        if (visualPos) {
                            const cell = boardEl.querySelector(`[data-row="${visualPos.r}"][data-col="${visualPos.c}"]`);
                            if (cell) {
                                const tokenEl = DOM.create('div', ['ludo-token', player.color]);
                                tokenEl.dataset.playerId = player.id;
                                tokenEl.dataset.tokenId = token.id;
                                tokenEl.textContent = token.id + 1;
                                tokenEl.onclick = () => sendLudoSelectToken(tokenEl); // Make clickable
                                // Position token inside the cell with slight offset for multiple tokens
                                const tokensOnCell = cell.querySelectorAll('.ludo-token').length;
                                tokenEl.style.left = `${5 + (tokensOnCell % 2 * 20)}px`;
                                tokenEl.style.top = `${5 + (Math.floor(tokensOnCell / 2) * 20)}px`;
                                cell.appendChild(tokenEl);
                            }
                        }
                    }
                });
                playerHomesEl.appendChild(playerHomeDiv);
            });

            // Highlight current player's home
            DOM.$$('#ludo-player-homes .ludo-player-home').forEach(div => div.classList.remove('current-player'));
            const currentPlayer = ludo.players[ludo.currentPlayerIndex];
            if (currentPlayer) {
                const currentPlayerHomeEl = DOM.$(`.ludo-player-home.${currentPlayer.color}`);
                if (currentPlayerHomeEl) {
                    currentPlayerHomeEl.classList.add('current-player');
                }
            }
        }

        /**
         * Initializes a new Ludo game. (For LOCAL PLAY ONLY now)
         */
        function initLudoGame() {
            ludo = { // Reset ludo object
                players: [],
                currentPlayerIndex: 0,
                diceRoll: 0,
                board: [],
                state: 'await_roll',
                selectedToken: null,
                consecutiveSixes: 0
            };

            const initialPlayers = [];
            for (let i = 1; i <= LUDO_COLORS.length; i++) {
                const name = DOM.$(`#ludo-player${i}-name`).value || `Player ${i}`;
                const mode = DOM.$(`input[name="ludo-player${i}-mode"]:checked`).value;
                initialPlayers.push({ name, mode, color: LUDO_COLORS[i-1] });
            }

            initialPlayers.forEach((p, i) => {
                ludo.players.push({
                    id: `p${i + 1}`,
                    name: p.name,
                    color: p.color,
                    mode: p.mode,
                    tokens: Array(LUDO_TOKENS_PER_PLAYER).fill(0).map((_, tid) => ({
                        id: tid,
                        position: -1,
                        finished: false
                    })),
                    finishedTokens: 0,
                    rollsWithoutMove: 0
                });
            });

            renderLudoBoard();
            updateLudoStatus(`${ludo.players[ludo.currentPlayerIndex].name}'s turn. Roll the dice!`);
            handleLudoTurnLocal(); // Call local turn handler
        }

        /**
         * Updates the Ludo game status message displayed to the user.
         * @param {string} message The message to display.
         */
        function updateLudoStatus(message) {
            DOM.$('#ludo-status').textContent = message;
        }

        /**
         * Manages the current player's turn for LOCAL Ludo.
         */
        function handleLudoTurnLocal() {
            const currentPlayer = ludo.players[ludo.currentPlayerIndex];
            updateLudoStatus(`${currentPlayer.name}'s turn (${currentPlayer.color}).`);
            renderLudoBoard();

            if (ludo.state === 'game_over') return;

            if (currentPlayer.mode === 'bot') {
                setTimeout(ludoBotTurnLocal, 1500); // Give a little delay for bot action
            } else {
                DOM.$('#ludo-dice').style.display = 'block';
                DOM.$('#ludo-move-button').style.display = 'none';
                DOM.$('#ludo-dice').style.pointerEvents = 'auto'; // Enable dice for human
                DOM.$('#ludo-dice').style.opacity = '1';
            }
        }

        /**
         * Rolls the Ludo dice and processes the outcome (LOCAL PLAY).
         */
        function rollLudoDice() { // This is now for LOCAL PLAY
            if (ludo.state !== 'await_roll') return;

            ludo.diceRoll = Math.floor(Math.random() * 6) + 1;
            DOM.$('#ludo-dice').textContent = ludo.diceRoll;
            updateLudoStatus(`${ludo.players[ludo.currentPlayerIndex].name} rolled a ${ludo.diceRoll}.`);

            const currentPlayer = ludo.players[ludo.currentPlayerIndex];

            if (ludo.diceRoll === 6) {
                ludo.consecutiveSixes++;
                if (ludo.consecutiveSixes === 3) {
                    updateLudoStatus(`${currentPlayer.name} rolled three 6s! No move, turn skipped.`);
                    ludo.consecutiveSixes = 0;
                    ludo.state = 'await_roll';
                    setTimeout(nextLudoTurnLocal, 1500);
                    return;
                }
            } else {
                ludo.consecutiveSixes = 0;
            }

            let possibleMoves = getLudoPossibleMoves(currentPlayer, ludo.diceRoll);

            if (possibleMoves.length === 0) {
                updateLudoStatus(`No moves possible for ${currentPlayer.name}.`);
                currentPlayer.rollsWithoutMove++;
                if (ludo.diceRoll !== 6 || currentPlayer.rollsWithoutMove >= 3) {
                     updateLudoStatus(`${currentPlayer.name} couldn't move. Skipping to next player.`);
                     ludo.state = 'await_roll';
                     setTimeout(nextLudoTurnLocal, 1500);
                     return;
                }
                if (ludo.diceRoll === 6) { // If 6 rolled but no moves, gets another roll
                    updateLudoStatus(`${currentPlayer.name} rolled a 6 but has no moves. Rolling again...`);
                    ludo.state = 'await_roll';
                    setTimeout(handleLudoTurnLocal, 1500);
                    return;
                }
            } else {
                currentPlayer.rollsWithoutMove = 0;
            }

            DOM.$('#ludo-dice').style.pointerEvents = 'none'; // Disable dice after roll
            DOM.$('#ludo-dice').style.opacity = '0.6';

            DOM.$$('#ludo-board .ludo-token, #ludo-player-homes .ludo-token').forEach(tokenEl => {
                const tokenId = parseInt(tokenEl.dataset.tokenId);
                const isMovable = possibleMoves.some(move => move.tokenId === tokenId);
                tokenEl.classList.toggle('active', isMovable);
                if (isMovable) {
                    tokenEl.onclick = () => selectLudoToken(tokenEl); // Local select
                } else {
                    tokenEl.onclick = null;
                }
            });

            ludo.state = 'await_move';
            DOM.$('#ludo-move-button').style.display = 'none'; // Will show if token is explicitly selected

            if (possibleMoves.length === 1 && currentPlayer.mode === 'human') {
                const tokenEl = DOM.$(`[data-player-id="${currentPlayer.id}"][data-token-id="${possibleMoves[0].tokenId}"]`);
                selectLudoToken(tokenEl);
            }
        }

        /**
         * Calculates all possible legal moves for a given player with a given dice roll.
         * @param {object} player The current player object.
         * @param {number} roll The dice roll.
         * @returns {Array<object>} An array of possible moves, each with tokenId and newPosition.
         */
        function getLudoPossibleMoves(player, roll) {
            const moves = [];
            player.tokens.forEach(token => {
                if (token.finished) return;

                const mainPathLength = LUDO_PATH_COORDS.length;
                const homePathLength = LUDO_PLAYER_HOME_PATHS[player.color].length;
                const finishPosition = mainPathLength + homePathLength; // Conceptual index of the finish center

                if (token.position === -1) { // Token is in its home base
                    if (roll === 6) {
                        moves.push({ tokenId: token.id, newPosition: 0, fromHome: true });
                    }
                } else { // Token is on the path (main or home stretch)
                    let newLogicalPosition = token.position + roll;

                    if (newLogicalPosition < finishPosition) { // Lands on a spot before the finish center
                        moves.push({ tokenId: token.id, newPosition: newLogicalPosition });
                    } else if (newLogicalPosition === finishPosition) { // Exactly lands on finish center
                        moves.push({ tokenId: token.id, newPosition: newLogicalPosition, finish: true });
                    }
                }
            });
            return moves;
        }

        /**
         * Selects a Ludo token for movement (LOCAL PLAY).
         * @param {HTMLElement} tokenEl The DOM element of the selected token.
         */
        function selectLudoToken(tokenEl) {
            if (ludo.state !== 'await_move') return;

            const playerId = tokenEl.dataset.playerId;
            const tokenId = parseInt(tokenEl.dataset.tokenId);
            const currentPlayer = ludo.players[ludo.currentPlayerIndex];

            if (playerId !== currentPlayer.id) return;

            const possibleMovesForRoll = getLudoPossibleMoves(currentPlayer, ludo.diceRoll);
            const isTokenMovable = possibleMovesForRoll.some(move => move.tokenId === tokenId);

            if (!isTokenMovable) {
                updateLudoStatus("This token cannot be moved with the current dice roll.");
                return;
            }

            if (ludo.selectedToken) {
                const prevSelectedEl = DOM.$(`[data-player-id="${ludo.selectedToken.playerId}"][data-token-id="${ludo.selectedToken.tokenId}"]`);
                if (prevSelectedEl) prevSelectedEl.classList.remove('selected');
            }

            ludo.selectedToken = { playerId, tokenId };
            tokenEl.classList.add('selected');
            DOM.$('#ludo-move-button').style.display = 'block';
        }

        /**
         * Confirms and executes the selected Ludo token move (LOCAL PLAY).
         */
        function confirmLudoMove() {
            if (!ludo.selectedToken || ludo.state !== 'await_move') return;

            const currentPlayer = ludo.players[ludo.currentPlayerIndex];
            const token = currentPlayer.tokens.find(t => t.id === ludo.selectedToken.tokenId);
            const roll = ludo.diceRoll;

            const possibleMoves = getLudoPossibleMoves(currentPlayer, roll);
            const chosenMove = possibleMoves.find(move => move.tokenId === token.id);

            if (!chosenMove) {
                updateLudoStatus("Invalid move. Please select a valid token.");
                ludo.selectedToken = null;
                DOM.$('#ludo-move-button').style.display = 'none';
                return;
            }

            let hadCapture = false;
            
            const globalTargetCoord = getLudoVisualPosition(currentPlayer.color, chosenMove.newPosition);

            if (token.position === -1) {
                token.position = chosenMove.newPosition;
                updateLudoStatus(`${currentPlayer.name}'s token ${token.id + 1} moved out of home!`);
            } else {
                if (globalTargetCoord && !isLudoGlobalSafeSpot(globalTargetCoord.r, globalTargetCoord.c)) {
                    const otherTokensOnDestination = [];
                    ludo.players.forEach(otherPlayer => {
                        if (otherPlayer.id === currentPlayer.id) return;
                        otherPlayer.tokens.forEach(otherToken => {
                            if (!otherToken.finished && otherToken.position !== -1) {
                                const otherGlobalPos = getLudoVisualPosition(otherPlayer.color, otherToken.position);
                                if (otherGlobalPos && otherGlobalPos.r === globalTargetCoord.r && otherGlobalPos.c === globalTargetCoord.c) {
                                    otherTokensOnDestination.push({player: otherPlayer, token: otherToken});
                                }
                            }
                        });
                    });

                    if (otherTokensOnDestination.length > 0) {
                        otherTokensOnDestination.forEach(captured => {
                            captured.token.position = -1;
                            updateLudoStatus(`${currentPlayer.name} captured ${captured.player.name}'s token ${captured.token.id + 1}!`);
                            hadCapture = true;
                        });
                    }
                }
                token.position = chosenMove.newPosition;
            }

            if (chosenMove.finish) {
                token.finished = true;
                currentPlayer.finishedTokens++;
                updateLudoStatus(`${currentPlayer.name}'s token ${token.id + 1} finished!`);
            }

            renderLudoBoard();
            ludo.selectedToken = null;
            DOM.$('#ludo-move-button').style.display = 'none';
            DOM.$$('#ludo-board .ludo-token, #ludo-player-homes .ludo-token').forEach(t => t.classList.remove('active'));

            if (currentPlayer.finishedTokens === LUDO_TOKENS_PER_PLAYER) {
                updateLudoStatus(`${currentPlayer.name} wins the Ludo game!`);
                ludo.state = 'game_over';
                return;
            }

            const getsAnotherTurn = (ludo.diceRoll === 6) || chosenMove.fromHome || hadCapture;

            if (getsAnotherTurn) {
                updateLudoStatus(`${currentPlayer.name} gets another turn! Roll again.`);
                ludo.state = 'await_roll';
                setTimeout(handleLudoTurnLocal, 1000);
            } else {
                nextLudoTurnLocal();
            }
        }

        /**
         * Advances to the next player's turn (LOCAL PLAY).
         */
        function nextLudoTurnLocal() {
            if (ludo.state === 'game_over') return;
            ludo.currentPlayerIndex = (ludo.currentPlayerIndex + 1) % ludo.players.length;
            ludo.state = 'await_roll';
            ludo.consecutiveSixes = 0;
            DOM.$('#ludo-dice').textContent = 'Roll Dice';
            handleLudoTurnLocal();
        }

        /**
         * Implements the basic AI logic for a bot player's Ludo turn (LOCAL PLAY).
         */
        function ludoBotTurnLocal() {
            const currentPlayer = ludo.players[ludo.currentPlayerIndex];
            updateLudoStatus(`${currentPlayer.name} (Bot) is thinking...`);

            setTimeout(() => {
                rollLudoDice();
                
                if (ludo.state === 'await_roll' || ludo.state === 'game_over') {
                    return;
                }

                const possibleMoves = getLudoPossibleMoves(currentPlayer, ludo.diceRoll);

                let chosenMove = null;

                if (ludo.diceRoll === 6) {
                    chosenMove = possibleMoves.find(m => currentPlayer.tokens.find(t => t.id === m.tokenId).position === -1);
                }

                if (!chosenMove) {
                    let captureMove = null;
                    for (const move of possibleMoves) {
                        const targetGlobalCoord = getLudoVisualPosition(currentPlayer.color, move.newPosition);
                        if (targetGlobalCoord && !isLudoGlobalSafeSpot(targetGlobalCoord.r, targetGlobalCoord.c)) {
                            const opponentTokens = ludo.players.flatMap(p => p.id === currentPlayer.id ? [] : p.tokens);
                            if (opponentTokens.some(ot => {
                                if (ot.finished || ot.position === -1) return false;
                                const otPlayer = ludo.players.find(p => p.id === ot.player); // Correctly find player for ot.player
                                const otGlobalPos = getLudoVisualPosition(otPlayer ? otPlayer.color : '', ot.position);
                                return otGlobalPos && otGlobalPos.r === targetGlobalCoord.r && otGlobalPos.c === targetGlobalCoord.c;
                            })) {
                                captureMove = move;
                                break;
                            }
                        }
                    }
                    if (captureMove) chosenMove = captureMove;
                }

                if (!chosenMove) {
                    let bestPositionScore = -1;
                    possibleMoves.forEach(move => {
                        let score = move.newPosition;
                        if (move.finish) score += 100;
                        if (score > bestPositionScore) {
                            bestPositionScore = score;
                            chosenMove = move;
                        }
                    });
                }

                if (chosenMove) {
                    ludo.selectedToken = { playerId: currentPlayer.id, tokenId: chosenMove.tokenId };
                    confirmLudoMove();
                } else {
                    updateLudoStatus(`Bot ${currentPlayer.name} made no valid move and ended its turn.`);
                    nextLudoTurnLocal();
                }
            }, 1500);
        }

        // --- PASTE MONOPOLY GAME JAVASCRIPT HERE ---

        // ===========================================================================================
        // MONOPOLY GAME (Advanced Simplified)
        // ===========================================================================================
        // let monopoly = { ... }; // Declared globally

        const MONOPOLY_BOARD_SETUP = [
            { name: "Go", type: "go", value: 200, group: "corner" }, // 0
            { name: "Mediterranean Avenue", type: "property", group: "dark-purple", price: 60, rent: [2, 10, 30, 90, 160, 250], houseCost: 50 }, // 1
            { name: "Community Chest", type: "chest", group: "action" }, // 2
            { name: "Baltic Avenue", type: "property", group: "dark-purple", price: 60, rent: [4, 20, 60, 180, 320, 450], houseCost: 50 }, // 3
            { name: "Income Tax", type: "tax", group: "tax", amount: 200 }, // 4
            { name: "Reading Railroad", type: "railroad", group: "railroad", price: 200, rent: [25, 50, 100, 200] }, // 5
            { name: "Oriental Avenue", type: "property", group: "light-blue", price: 100, rent: [6, 30, 90, 270, 400, 550], houseCost: 50 }, // 6
            { name: "Chance", type: "chance", group: "action" }, // 7
            { name: "Vermont Avenue", type: "property", group: "light-blue", price: 100, rent: [6, 30, 90, 270, 400, 550], houseCost: 50 }, // 8
            { name: "Connecticut Avenue", type: "property", group: "light-blue", price: 120, rent: [8, 40, 100, 300, 450, 600], houseCost: 50 }, // 9
            { name: "Jail / Just Visiting", type: "jail", group: "corner" }, // 10
            { name: "St. Charles Place", type: "property", group: "pink", price: 140, rent: [10, 50, 150, 450, 625, 750], houseCost: 100 }, // 11
            { name: "Electric Company", type: "utility", group: "utility", price: 150, rent: [4, 10] }, // 12 (rent is 4x or 10x dice)
            { name: "States Avenue", type: "property", group: "pink", price: 140, rent: [10, 50, 150, 450, 625, 750], houseCost: 100 }, // 13
            { name: "Virginia Avenue", type: "property", group: "pink", price: 160, rent: [12, 60, 180, 500, 700, 900], houseCost: 100 }, // 14
            { name: "Pennsylvania Railroad", type: "railroad", group: "railroad", price: 200, rent: [25, 50, 100, 200] }, // 15
            { name: "St. James Place", type: "property", group: "orange", price: 180, rent: [14, 70, 200, 550, 750, 950], houseCost: 100 }, // 16
            { name: "Community Chest", type: "chest", group: "action" }, // 17
            { name: "Tennessee Avenue", type: "property", group: "orange", price: 180, rent: [14, 70, 200, 550, 750, 950], houseCost: 100 }, // 18
            { name: "New York Avenue", type: "property", group: "orange", price: 200, rent: [16, 80, 220, 600, 800, 1000], houseCost: 100 }, // 19
            { name: "Free Parking", type: "free-parking", group: "corner" }, // 20
            { name: "Kentucky Avenue", type: "property", group: "red", price: 220, rent: [18, 90, 250, 700, 875, 1050], houseCost: 150 }, // 21
            { name: "Chance", type: "chance", group: "action" }, // 22
            { name: "Indiana Avenue", type: "property", group: "red", price: 220, rent: [18, 90, 250, 700, 875, 1050], houseCost: 150 }, // 23
            { name: "Illinois Avenue", type: "property", group: "red", price: 240, rent: [20, 100, 300, 750, 925, 1100], houseCost: 150 }, // 24
            { name: "B. & O. Railroad", type: "railroad", group: "railroad", price: 200, rent: [25, 50, 100, 200] }, // 25
            { name: "Atlantic Avenue", type: "property", group: "yellow", price: 260, rent: [22, 110, 330, 800, 975, 1150], houseCost: 150 }, // 26
            { name: "Ventnor Avenue", type: "property", group: "yellow", price: 260, rent: [22, 110, 330, 800, 975, 1150], houseCost: 150 }, // 27
            { name: "Water Works", type: "utility", group: "utility", price: 150, rent: [4, 10] }, // 28
            { name: "Marvin Gardens", type: "property", group: "yellow", price: 280, rent: [24, 120, 360, 850, 1025, 1200], houseCost: 150 }, // 29
            { name: "Go To Jail", type: "go-to-jail", group: "corner" }, // 30
            { name: "Pacific Avenue", type: "property", group: "green", price: 300, rent: [26, 130, 390, 900, 1100, 1275], houseCost: 200 }, // 31
            { name: "North Carolina Avenue", type: "property", group: "green", price: 300, rent: [26, 130, 390, 900, 1100, 1275], houseCost: 200 }, // 32
            { name: "Community Chest", type: "chest", group: "action" }, // 33
            { name: "Pennsylvania Avenue", type: "property", group: "green", price: 320, rent: [28, 150, 450, 1000, 1200, 1400], houseCost: 200 }, // 34
            { name: "Short Line", type: "railroad", group: "railroad", price: 200, rent: [25, 50, 100, 200] }, // 35
            { name: "Chance", type: "chance", group: "action" }, // 36
            { name: "Park Place", type: "property", group: "dark-blue", price: 350, rent: [35, 175, 500, 1100, 1300, 1500], houseCost: 200 }, // 37
            { name: "Luxury Tax", type: "tax", group: "tax", amount: 100 }, // 38
            { name: "Boardwalk", type: "property", group: "dark-blue", price: 400, rent: [50, 200, 600, 1400, 1700, 2000], houseCost: 200 } // 39
        ];

        // Simplified Chance Cards
        const MONOPOLY_CHANCE_CARDS = [
            { text: "Advance to Go (Collect $200)", action: (player) => { player.position = 0; player.balance += 200; return "Advance to Go (Collect $200)"; } },
            { text: "Go to Jail. Go directly to Jail. Do not pass Go. Do not collect $200.", action: (player) => { sendMonopolyPlayerToJailLocal(player); return "Go to Jail!"; } },
            { text: "Bank pays you dividend of $50.", action: (player) => { player.balance += 50; return "Bank pays you dividend of $50."; } },
            { text: "Go Back 3 Spaces.", action: (player) => { player.position = (player.position - 3 + 40) % 40; return "Go Back 3 Spaces."; } },
            { text: "Pay poor tax of $15.", action: (player) => { player.balance -= 15; return "Pay poor tax of $15."; } },
            { text: "Advance to Illinois Ave. If you pass Go, collect $200.", action: (player) => { if (player.position > 24) player.balance += 200; player.position = 24; return "Advance to Illinois Ave."; } },
            { text: "Advance to St. Charles Place. If you pass Go, collect $200.", action: (player) => { if (player.position > 11) player.balance += 200; player.position = 11; return "Advance to St. Charles Place."; } },
            { text: "Your building loan matures. Collect $150.", action: (player) => { player.balance += 150; return "Your building loan matures. Collect $150."; } }
        ];

        // Simplified Community Chest Cards
        const MONOPOLY_COMMUNITY_CHEST_CARDS = [
            { text: "Advance to Go (Collect $200)", action: (player) => { player.position = 0; player.balance += 200; return "Advance to Go (Collect $200)"; } },
            { text: "Bank error in your favor. Collect $200.", action: (player) => { player.balance += 200; return "Bank error in your favor. Collect $200."; } },
            { text: "Doctor's fee. Pay $50.", action: (player) => { player.balance -= 50; return "Doctor's fee. Pay $50."; } },
            { text: "Go to Jail. Go directly to Jail. Do not pass Go. Do not collect $200.", action: (player) => { sendMonopolyPlayerToJailLocal(player); return "Go to Jail!"; } },
            { text: "Holiday fund matures. Collect $100.", action: (player) => { player.balance += 100; return "Holiday fund matures. Collect $100."; } },
            { text: "Income tax refund. Collect $20.", action: (player) => { player.balance += 20; return "Income tax refund. Collect $20."; } },
            { text: "It is your birthday. Collect $10 from each player.", action: (player) => { monopoly.players.forEach(p => { if (p.id !== player.id) { p.balance -= 10; player.balance += 10; } }); return "It is your birthday. Collect $10 from each player."; } },
            { text: "Life insurance matures. Collect $100.", action: (player) => { player.balance += 100; return "Life insurance matures. Collect $100."; } }
        ];


        /**
         * Initializes the Monopoly board visual elements.
         */
        function initMonopolyBoardDOM() {
            const boardEl = DOM.$('#monopoly-board');
            boardEl.innerHTML = ''; // Clear previous board

            // Board cell mapping from index to grid position (r,c) for 11x11 visual grid
            const boardCellsMapping = [];
            // Top row (from Free Parking 20 to Go To Jail 30)
            boardCellsMapping[20] = {r:0, c:0};
            for (let i = 21; i <= 29; i++) boardCellsMapping[i] = { r: 0, c: 1 + (i - 21) };
            boardCellsMapping[30] = {r:0, c:10};

            // Right column (from Go To Jail 30 to Go 0)
            for (let i = 31; i <= 39; i++) boardCellsMapping[i] = { r: 1 + (i - 31), c: 10 };
            boardCellsMapping[0] = {r:10, c:10};

            // Bottom row (from Go 0 to Jail 10)
            for (let i = 1; i <= 9; i++) boardCellsMapping[i] = { r: 10, c: 9 - (i - 1) };
            boardCellsMapping[10] = {r:10, c:0};

            // Left column (from Jail 10 to Free Parking 20)
            for (let i = 11; i <= 19; i++) boardCellsMapping[i] = { r: 9 - (i - 11), c: 0 };


            for (let i = 0; i < 40; i++) {
                const squareData = MONOPOLY_BOARD_SETUP[i];
                const cell = DOM.create('div', ['monopoly-square']);
                cell.dataset.index = i;

                if (i % 10 === 0) cell.classList.add('corner');
                if (i >= 1 && i <= 9) cell.classList.add('bottom');
                else if (i >= 11 && i <= 19) cell.classList.add('left');
                else if (i >= 21 && i <= 29) cell.classList.add('top');
                else if (i >= 31 && i <= 39) cell.classList.add('right');

                // Color bar for properties
                if (squareData.group && !['railroad', 'utility', 'action', 'tax', 'corner'].includes(squareData.group)) {
                    const colorBar = DOM.create('div', ['color-bar', `color-${squareData.group}`]);
                    if (cell.classList.contains('bottom')) { colorBar.style.top = 'auto'; colorBar.style.bottom = '0'; }
                    if (cell.classList.contains('left')) { colorBar.style.top = '0'; colorBar.style.left = '0'; colorBar.style.width = '15px'; colorBar.style.height = '100%'; }
                    if (cell.classList.contains('right')) { colorBar.style.top = '0'; colorBar.style.right = '0'; colorBar.style.width = '15px'; colorBar.style.height = '100%'; }
                    cell.appendChild(colorBar);
                }

                cell.innerHTML += `<div class="square-name">${squareData.name}</div>`;
                if (squareData.price) {
                    cell.innerHTML += `<div class="square-price">$${squareData.price}</div>`;
                }
                // Display initial rent if it's a property (index 0 of rent array)
                if (squareData.rent && squareData.type === 'property') {
                    cell.innerHTML += `<div class="square-rent">Rent: $${squareData.rent[0]}</div>`;
                }

                const {r, c} = boardCellsMapping[i];
                cell.style.gridRow = r + 1;
                cell.style.gridColumn = c + 1;
                boardEl.appendChild(cell);
            }
        }

        /**
         * Initializes a new Monopoly game (LOCAL PLAY).
         */
        function initMonopolyGame() {
            monopoly = { // Reset monopoly object
                players: [],
                currentPlayerIndex: 0,
                board: [],
                dice: [0, 0],
                state: 'await_roll',
                doublesCount: 0,
                jailAttempts: 0,
                currentProperty: null,
                communityChestCards: [],
                chanceCards: [],
                communityChestDiscard: [],
                chanceDiscard: []
            };

            monopoly.communityChestCards = shuffleMonopolyCards([...MONOPOLY_COMMUNITY_CHEST_CARDS]);
            monopoly.chanceCards = shuffleMonopolyCards([...MONOPOLY_CHANCE_CARDS]);
            monopoly.communityChestDiscard = [];
            monopoly.chanceDiscard = [];

            const initialPlayers = [];
            for (let i = 1; i <= 4; i++) {
                const nameInput = DOM.$(`#monopoly-player${i}-name`);
                const modeRadios = DOM.$(`input[name="monopoly-player${i}-mode"]:checked`);
                if (nameInput && nameInput.value && modeRadios && modeRadios.value) {
                    initialPlayers.push({ name: nameInput.value, mode: modeRadios.value });
                }
            }

            if (initialPlayers.length < 2) {
                alert("Monopoly requires at least 2 players. Please set up more players.");
                showGameSetup('monopoly', 'local');
                return;
            }

            const MONOPOLY_PLAYER_COLORS = ['red', 'blue', 'green', 'yellow'];
            initialPlayers.forEach((p, i) => {
                monopoly.players.push({
                    id: `p${i + 1}`,
                    name: p.name,
                    color: MONOPOLY_PLAYER_COLORS[i],
                    mode: p.mode,
                    balance: 1500,
                    position: 0,
                    properties: [],
                    inJail: false,
                    jailTurns: 0
                });
            });

            monopoly.board = MONOPOLY_BOARD_SETUP.map((square, index) => ({
                ...square,
                owner: null,
                houses: 0,
                index: index
            }));

            renderMonopolyBoard();
            updateMonopolyPlayerHoldings();
            updateMonopolyStatus(`${monopoly.players[monopoly.currentPlayerIndex].name}'s turn. Roll the dice!`);
            handleMonopolyTurnLocal(); // Call local turn handler
        }

        /**
         * Shuffles an array of cards (utility for Chance/Community Chest).
         * @param {Array<object>} cards The array of card objects to shuffle.
         * @returns {Array<object>} The shuffled array.
         */
        function shuffleMonopolyCards(cards) {
            for (let i = cards.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [cards[i], cards[j]] = [cards[j], cards[i]];
            }
            return cards;
        }

        /**
         * Renders or re-renders the Monopoly game board and player tokens.
         */
        function renderMonopolyBoard() {
            initMonopolyBoardDOM();
            const boardEl = DOM.$('#monopoly-board');
            DOM.$$('#monopoly-board .monopoly-token').forEach(token => token.remove());

            monopoly.players.forEach((player, pIdx) => {
                const tokenEl = DOM.create('div', ['monopoly-token', `p${pIdx + 1}`], `P${pIdx + 1}`);
                tokenEl.dataset.playerId = player.id;
                
                const squareEl = boardEl.querySelector(`[data-index="${player.position}"]`);
                if (squareEl) {
                    const tokensOnSquare = squareEl.querySelectorAll('.monopoly-token').length;
                    tokenEl.style.left = `${10 + (tokensOnSquare * 15)}px`;
                    tokenEl.style.top = `${10 + (tokensOnSquare * 15)}px`;
                    squareEl.appendChild(tokenEl);
                }
            });

            monopoly.board.forEach(square => {
                const squareEl = boardEl.querySelector(`[data-index="${square.index}"]`);
                if (squareEl && square.owner) {
                    const ownerPlayer = monopoly.players.find(p => p.id === square.owner);
                    if (ownerPlayer) {
                        squareEl.style.borderColor = ownerPlayer.color;
                        squareEl.style.boxShadow = `inset 0 0 5px ${ownerPlayer.color}`;
                    }
                } else if (squareEl) {
                    squareEl.style.borderColor = '';
                    squareEl.style.boxShadow = '';
                }
            });
        }

        /**
         * Updates the Monopoly game status message.
         * @param {string} message The message to display.
         */
        function updateMonopolyStatus(message) {
            DOM.$('#monopoly-status').textContent = message;
        }

        /**
         * Updates the display of each player's name, balance, and owned properties.
         */
        function updateMonopolyPlayerHoldings() {
            const holdingsEl = DOM.$('#monopoly-player-holdings');
            holdingsEl.innerHTML = '';
            monopoly.players.forEach(player => {
                const playerCard = DOM.create('div', ['monopoly-player-card']);
                playerCard.innerHTML = `<h4>${player.name} (${player.color}) - $${player.balance}</h4>`;
                const ul = DOM.create('ul');
                if (player.properties.length === 0) {
                    ul.innerHTML = '<li>No properties</li>';
                } else {
                    player.properties.sort((a,b) => a - b).forEach(propIndex => {
                        const prop = monopoly.board[propIndex];
                        const li = DOM.create('li', [], `${prop.name} ($${prop.price})`);
                        ul.appendChild(li);
                    });
                }
                playerCard.appendChild(ul);
                holdingsEl.appendChild(playerCard);
            });

            const currentPlayer = monopoly.players[monopoly.currentPlayerIndex];
            DOM.$('#monopoly-current-player-name').textContent = currentPlayer ? currentPlayer.name : 'N/A';
            DOM.$('#monopoly-current-player-balance').textContent = currentPlayer ? `$${currentPlayer.balance}` : '$0';
        }

        /**
         * Handles the start of a new turn for the current player (LOCAL PLAY).
         */
        function handleMonopolyTurnLocal() {
            if (monopoly.state === 'game_over') return;

            const currentPlayer = monopoly.players[monopoly.currentPlayerIndex];
            updateMonopolyPlayerHoldings();
            updateMonopolyStatus(`${currentPlayer.name}'s turn (${currentPlayer.color}).`);

            DOM.$('#monopoly-roll-dice-button').style.display = 'block';
            DOM.$('#monopoly-buy-button').style.display = 'none';
            DOM.$('#monopoly-end-turn-button').style.display = 'none';
            hideMonopolyPopup();

            if (currentPlayer.inJail) {
                updateMonopolyStatus(`${currentPlayer.name} is in jail. Roll doubles to get out (Attempt ${currentPlayer.jailTurns+1}/3).`);
                DOM.$('#monopoly-roll-dice-button').textContent = 'Roll for Jail';
            } else {
                DOM.$('#monopoly-roll-dice-button').textContent = 'Roll Dice';
            }
            DOM.$('#monopoly-roll-dice-button').disabled = false; // Enable roll button for local

            if (currentPlayer.mode === 'bot') {
                setTimeout(monopolyBotTurnLocal, 1500);
            }
        }

        /**
         * Rolls the two dice and processes the player's movement and landing (LOCAL PLAY).
         */
        function rollMonopolyDice() { // LOCAL PLAY
            if (monopoly.state !== 'await_roll') return;

            const currentPlayer = monopoly.players[monopoly.currentPlayerIndex];
            const die1 = Math.floor(Math.random() * 6) + 1;
            const die2 = Math.floor(Math.random() * 6) + 1;
            monopoly.dice = [die1, die2];

            DOM.$('#monopoly-die1').textContent = die1;
            DOM.$('#monopoly-die2').textContent = die2;

            const isDoubles = (die1 === die2);
            updateMonopolyStatus(`${currentPlayer.name} rolled a ${die1} and a ${die2}. ${isDoubles ? 'Doubles!' : ''}`);
            DOM.$('#monopoly-roll-dice-button').disabled = true; // Disable roll button after rolling

            if (currentPlayer.inJail) {
                if (isDoubles) {
                    currentPlayer.inJail = false;
                    currentPlayer.jailTurns = 0;
                    updateMonopolyStatus(`${currentPlayer.name} rolled doubles and is out of jail!`);
                    moveMonopolyPlayerLocal(currentPlayer, die1 + die2);
                    monopoly.state = 'post_roll';
                    processMonopolyLandingLocal();
                } else {
                    currentPlayer.jailTurns++;
                    if (currentPlayer.jailTurns >= 3) {
                        currentPlayer.inJail = false;
                        currentPlayer.jailTurns = 0;
                        if (currentPlayer.balance >= 50) {
                            currentPlayer.balance -= 50;
                            updateMonopolyStatus(`${currentPlayer.name} paid $50 to get out of jail.`);
                        } else {
                            updateMonopolyStatus(`${currentPlayer.name} cannot pay $50 to get out of jail and is bankrupt!`);
                            checkMonopolyBankruptcyLocal();
                            if (monopoly.state === 'game_over') return;
                        }
                        moveMonopolyPlayerLocal(currentPlayer, die1 + die2);
                        monopoly.state = 'post_roll';
                        processMonopolyLandingLocal();
                    } else {
                        updateMonopolyStatus(`${currentPlayer.name} is still in jail. ${3 - currentPlayer.jailTurns} attempts left.`);
                        setTimeout(nextMonopolyTurnLocal, 2000);
                    }
                }
                return;
            }

            if (isDoubles) {
                monopoly.doublesCount++;
                if (monopoly.doublesCount === 3) {
                    updateMonopolyStatus(`${currentPlayer.name} rolled 3 doubles! Go to Jail!`);
                    sendMonopolyPlayerToJailLocal(currentPlayer);
                    monopoly.doublesCount = 0;
                    setTimeout(nextMonopolyTurnLocal, 2000);
                    return;
                }
            } else {
                monopoly.doublesCount = 0;
            }

            moveMonopolyPlayerLocal(currentPlayer, die1 + die2);
            monopoly.state = 'post_roll';
            processMonopolyLandingLocal();
        }

        /**
         * Moves a player a specified number of steps on the board (LOCAL PLAY).
         * Handles passing Go.
         * @param {object} player The player object to move.
         * @param {number} steps The number of spaces to move.
         */
        function moveMonopolyPlayerLocal(player, steps) {
            const oldPos = player.position;
            player.position = (player.position + steps) % monopoly.board.length;
            renderMonopolyBoard();

            if (player.position < oldPos) {
                player.balance += monopoly.board[0].value;
                updateMonopolyStatus(`${player.name} passed Go and collected $${monopoly.board[0].value}.`);
            }
        }

        /**
         * Processes the actions when a player lands on a specific square (LOCAL PLAY).
         */
        function processMonopolyLandingLocal() {
            const currentPlayer = monopoly.players[monopoly.currentPlayerIndex];
            const square = monopoly.board[currentPlayer.position];
            monopoly.currentProperty = square;

            let actionTaken = false;

            switch (square.type) {
                case "go":
                case "jail":
                case "free-parking":
                    updateMonopolyStatus(`${currentPlayer.name} landed on ${square.name}.`);
                    actionTaken = true;
                    break;
                case "go-to-jail":
                    updateMonopolyStatus(`${currentPlayer.name} landed on Go To Jail!`);
                    sendMonopolyPlayerToJailLocal(currentPlayer);
                    actionTaken = true;
                    break;
                case "tax":
                    if (currentPlayer.balance >= square.amount) {
                        currentPlayer.balance -= square.amount;
                        updateMonopolyStatus(`${currentPlayer.name} paid $${square.amount} for ${square.name}. Balance: $${currentPlayer.balance}.`);
                    } else {
                        updateMonopolyStatus(`${currentPlayer.name} cannot pay $${square.amount} tax and is bankrupt!`);
                        checkMonopolyBankruptcyLocal();
                        if (monopoly.state === 'game_over') return;
                    }
                    actionTaken = true;
                    break;
                case "property":
                case "railroad":
                case "utility":
                    if (square.owner === null) {
                        updateMonopolyStatus(`${currentPlayer.name} landed on ${square.name} (Price: $${square.price}).`);
                        if (currentPlayer.balance >= square.price) {
                            DOM.$('#monopoly-buy-button').style.display = 'block';
                            actionTaken = false;
                        } else {
                            updateMonopolyStatus(`${currentPlayer.name} cannot afford ${square.name}.`);
                            actionTaken = true;
                        }
                    } else if (square.owner === currentPlayer.id) {
                        updateMonopolyStatus(`${currentPlayer.name} landed on their own property: ${square.name}.`);
                        actionTaken = true;
                    } else {
                        const ownerPlayer = monopoly.players.find(p => p.id === square.owner);
                        if (!ownerPlayer) {
                            square.owner = null;
                            updateMonopolyStatus(`${currentPlayer.name} landed on ${square.name}, which is now unowned.`);
                            DOM.$('#monopoly-buy-button').style.display = 'block';
                            actionTaken = false;
                            break;
                        }

                        let rent = 0;
                        if (square.type === 'property') {
                            const numHouses = square.houses;
                            const propertiesInGroup = monopoly.board.filter(s => s.group === square.group && s.type === 'property');
                            const ownerOwnsAll = propertiesInGroup.every(p => p.owner === ownerPlayer.id);
                            
                            if (numHouses === 0 && ownerOwnsAll) {
                                rent = square.rent[0] * 2;
                            } else {
                                rent = square.rent[numHouses];
                            }
                        } else if (square.type === 'railroad') {
                            const ownedRailroads = monopoly.board.filter(s => s.type === 'railroad' && s.owner === ownerPlayer.id).length;
                            rent = square.rent[ownedRailroads - 1];
                        } else if (square.type === 'utility') {
                            const ownedUtilities = monopoly.board.filter(s => s.type === 'utility' && s.owner === ownerPlayer.id).length;
                            rent = (ownedUtilities === 1 ? square.rent[0] : square.rent[1]) * (monopoly.dice[0] + monopoly.dice[1]);
                        }

                        if (currentPlayer.balance >= rent) {
                            currentPlayer.balance -= rent;
                            ownerPlayer.balance += rent;
                            updateMonopolyStatus(`${currentPlayer.name} paid $${rent} rent to ${ownerPlayer.name} for ${square.name}.`);
                        } else {
                            updateMonopolyStatus(`${currentPlayer.name} cannot pay $${rent} rent to ${ownerPlayer.name} and is bankrupt!`);
                            checkMonopolyBankruptcyLocal();
                            if (monopoly.state === 'game_over') return;
                        }
                        actionTaken = true;
                    }
                    break;
                case "chance":
                    monopoly.state = 'chance';
                    const chanceCard = drawMonopolyCardLocal('chance');
                    showMonopolyPopup(`Chance: ${chanceCard.text}`, () => {
                        updateMonopolyStatus(chanceCard.action(currentPlayer));
                        processMonopolyLandingPostCardLocal();
                    });
                    actionTaken = false;
                    break;
                case "chest":
                    monopoly.state = 'community_chest';
                    const communityCard = drawMonopolyCardLocal('community_chest');
                    showMonopolyPopup(`Community Chest: ${communityCard.text}`, () => {
                        updateMonopolyStatus(communityCard.action(currentPlayer));
                        processMonopolyLandingPostCardLocal();
                    });
                    actionTaken = false;
                    break;
            }

            updateMonopolyPlayerHoldings();
            
            if (actionTaken && monopoly.state !== 'game_over') {
                if (monopoly.dice[0] === monopoly.dice[1] && !currentPlayer.inJail) {
                    monopoly.state = 'await_roll';
                    updateMonopolyStatus(`${currentPlayer.name} rolled doubles, roll again!`);
                    setTimeout(handleMonopolyTurnLocal, 1000);
                } else {
                    DOM.$('#monopoly-end-turn-button').style.display = 'block';
                }
            } else if (!actionTaken && currentPlayer.mode === 'human') {
                // Human player needs to decide (e.g., buy property or close popup)
            } else if (!actionTaken && currentPlayer.mode === 'bot') {
                setTimeout(monopolyBotDecisionLocal, 1000);
            }
        }

        /**
         * Helper function to call after a card has moved the player, to re-evaluate the new square (LOCAL PLAY).
         */
        function processMonopolyLandingPostCardLocal() {
            const currentPlayer = monopoly.players[monopoly.currentPlayerIndex];
            const square = monopoly.board[currentPlayer.position];
            monopoly.currentProperty = square;

            let actionTakenAfterCard = true;

            switch (square.type) {
                case "go":
                case "jail":
                case "free-parking":
                    updateMonopolyStatus(`... landing on ${square.name}.`);
                    break;
                case "go-to-jail":
                    updateMonopolyStatus(`... landing on Go To Jail!`);
                    sendMonopolyPlayerToJailLocal(currentPlayer);
                    break;
                case "tax":
                    if (currentPlayer.balance >= square.amount) {
                        currentPlayer.balance -= square.amount;
                        updateMonopolyStatus(`... landing on ${square.name} and paying $${square.amount}. Balance: $${currentPlayer.balance}.`);
                    } else {
                        updateMonopolyStatus(`... landing on ${square.name} and cannot pay $${square.amount} tax. Bankrupt!`);
                        checkMonopolyBankruptcyLocal();
                        if (monopoly.state === 'game_over') return;
                    }
                    break;
                case "property":
                case "railroad":
                case "utility":
                     if (square.owner === null) {
                        updateMonopolyStatus(`... landing on unowned ${square.name}. (Price: $${square.price}).`);
                        if (currentPlayer.balance >= square.price) {
                            DOM.$('#monopoly-buy-button').style.display = 'block';
                            actionTakenAfterCard = false;
                        } else {
                            updateMonopolyStatus(`... cannot afford ${square.name}.`);
                        }
                    } else if (square.owner === currentPlayer.id) {
                        updateMonopolyStatus(`... landing on their own property: ${square.name}.`);
                    } else {
                        const ownerPlayer = monopoly.players.find(p => p.id === square.owner);
                        if (!ownerPlayer) {
                            square.owner = null;
                            updateMonopolyStatus(`... landing on ${square.name}, which is now unowned.`);
                            DOM.$('#monopoly-buy-button').style.display = 'block';
                            actionTakenAfterCard = false;
                            break;
                        }
                        let rent = 0;
                        if (square.type === 'property') {
                            const numHouses = square.houses;
                            const propertiesInGroup = monopoly.board.filter(s => s.group === square.group && s.type === 'property');
                            const ownerOwnsAll = propertiesInGroup.every(p => p.owner === ownerPlayer.id);
                            
                            if (numHouses === 0 && ownerOwnsAll) {
                                rent = square.rent[0] * 2;
                            } else {
                                rent = square.rent[numHouses];
                            }
                        } else if (square.type === 'railroad') {
                            const ownedRailroads = monopoly.board.filter(s => s.type === 'railroad' && s.owner === ownerPlayer.id).length;
                            rent = square.rent[ownedRailroads - 1];
                        } else if (square.type === 'utility') {
                            const ownedUtilities = monopoly.board.filter(s => s.type === 'utility' && s.owner === ownerPlayer.id).length;
                            rent = (ownedUtilities === 1 ? square.rent[0] : square.rent[1]) * (monopoly.dice[0] + monopoly.dice[1]);
                        }

                        if (currentPlayer.balance >= rent) {
                            currentPlayer.balance -= rent;
                            ownerPlayer.balance += rent;
                            updateMonopolyStatus(`... paying $${rent} rent to ${ownerPlayer.name} for ${square.name}.`);
                        } else {
                            updateMonopolyStatus(`... cannot pay $${rent} rent to ${ownerPlayer.name}. Bankrupt!`);
                            checkMonopolyBankruptcyLocal();
                            if (monopoly.state === 'game_over') return;
                        }
                    }
                    break;
                case "chance":
                case "chest":
                    updateMonopolyStatus(`... landing on ${square.name}.`);
                    break;
            }
            renderMonopolyBoard();
            updateMonopolyPlayerHoldings();

            if (monopoly.state !== 'game_over') {
                if (actionTakenAfterCard && currentPlayer.mode === 'human') {
                    DOM.$('#monopoly-end-turn-button').style.display = 'block';
                } else if (!actionTakenAfterCard && currentPlayer.mode === 'bot') {
                    setTimeout(monopolyBotDecisionLocal, 1000);
                } else if (currentPlayer.mode === 'bot') {
                    monopolyEndTurn();
                }
            }
        }


        /**
         * Draws a card from the specified deck (Chance or Community Chest) (LOCAL PLAY).
         * If the deck is empty, reshuffles the discard pile.
         * @param {string} deckType 'chance' or 'community_chest'.
         * @returns {object} The drawn card.
         */
        function drawMonopolyCardLocal(deckType) {
            let deck = monopoly[`${deckType}Cards`];
            let discard = monopoly[`${deckType}Discard`];
            
            if (deck.length === 0) {
                if (discard.length === 0) {
                    updateMonopolyStatus(`No ${deckType} cards left!`);
                    return { text: "No card available.", action: () => "No effect." };
                }
                deck = shuffleMonopolyCards(discard);
                monopoly[`${deckType}Cards`] = deck;
                monopoly[`${deckType}Discard`] = [];
                updateMonopolyStatus(`Reshuffling ${deckType} discard pile.`);
            }

            const card = deck.pop();
            discard.push(card);
            return card;
        }

        /**
         * Displays a popup with a message and an "OK" button for Monopoly actions (like cards).
         * @param {string} message The message to display.
         * @param {Function} callback Function to execute when "OK" is clicked.
         */
        function showMonopolyPopup(message, callback) {
            const popup = DOM.$('#monopoly-action-popup');
            const popupMessage = DOM.$('#monopoly-popup-message');
            const popupButtons = DOM.$('#monopoly-popup-buttons');

            popupMessage.textContent = message;
            popupButtons.innerHTML = '';
            
            const okButton = DOM.create('button', [], 'OK');
            okButton.onclick = () => {
                hideMonopolyPopup();
                callback();
            };
            popupButtons.appendChild(okButton);
            popup.style.display = 'flex';
        }

        /**
         * Hides the Monopoly action popup.
         */
        function hideMonopolyPopup() {
            DOM.$('#monopoly-action-popup').style.display = 'none';
        }

        /**
         * Allows the current player to buy the property they landed on (LOCAL PLAY).
         */
        function monopolyBuyProperty() { // LOCAL PLAY
            const currentPlayer = monopoly.players[monopoly.currentPlayerIndex];
            const square = monopoly.currentProperty;

            if (!square || square.owner !== null || currentPlayer.balance < square.price) {
                updateMonopolyStatus("Cannot buy this property.");
                return;
            }

            currentPlayer.balance -= square.price;
            square.owner = currentPlayer.id;
            currentPlayer.properties.push(square.index);
            updateMonopolyStatus(`${currentPlayer.name} bought ${square.name} for $${square.price}.`);
            
            DOM.$('#monopoly-buy-button').style.display = 'none';
            DOM.$('#monopoly-roll-dice-button').style.display = 'none';
            DOM.$('#monopoly-end-turn-button').style.display = 'block';
            updateMonopolyPlayerHoldings();
            renderMonopolyBoard();
        }

        /**
         * Implements basic AI decision-making for a bot player (LOCAL PLAY).
         * Currently, bots always buy affordable unowned properties.
         */
        function monopolyBotDecisionLocal() {
            const currentPlayer = monopoly.players[monopoly.currentPlayerIndex];
            const square = monopoly.currentProperty;

            if (monopoly.state === 'chance' || monopoly.state === 'community_chest') {
                hideMonopolyPopup();
                monopoly.state = 'post_roll';
                processMonopolyLandingPostCardLocal();
                return;
            }

            if (square && square.owner === null && currentPlayer.balance >= square.price) {
                monopolyBuyProperty();
                if (monopoly.dice[0] === monopoly.dice[1] && !currentPlayer.inJail) {
                    monopoly.state = 'await_roll';
                    updateMonopolyStatus(`${currentPlayer.name} (Bot) bought ${square.name} and rolled doubles, rolling again!`);
                    setTimeout(handleMonopolyTurnLocal, 1500);
                } else {
                    setTimeout(monopolyEndTurn(), 1000); // Call local end turn
                }
            } else {
                updateMonopolyStatus(`${currentPlayer.name} (Bot) decided not to buy or couldn't afford ${square.name}.`);
                if (monopoly.dice[0] === monopoly.dice[1] && !currentPlayer.inJail) {
                    monopoly.state = 'await_roll';
                    updateMonopolyStatus(`${currentPlayer.name} (Bot) rolled doubles, rolling again!`);
                    setTimeout(handleMonopolyTurnLocal, 1500);
                } else {
                    setTimeout(monopolyEndTurn(), 1000); // Call local end turn
                }
            }
        }

        /**
         * Ends the current player's turn (LOCAL PLAY).
         */
        function monopolyEndTurn() { // LOCAL PLAY
            if (monopoly.state === 'game_over') return;
            DOM.$('#monopoly-buy-button').style.display = 'none';
            DOM.$('#monopoly-end-turn-button').style.display = 'none';
            nextMonopolyTurnLocal();
        }

        /**
         * Sends a player directly to Jail (LOCAL PLAY).
         * @param {object} player The player object to send to jail.
         */
        function sendMonopolyPlayerToJailLocal(player) {
            player.position = 10;
            player.inJail = true;
            player.jailTurns = 0;
            monopoly.doublesCount = 0;
            renderMonopolyBoard();
            updateMonopolyStatus(`${player.name} is now in Jail!`);
        }

        /**
         * Checks if the current player is bankrupt and handles game over conditions (LOCAL PLAY).
         */
        function checkMonopolyBankruptcyLocal() {
            const currentPlayer = monopoly.players[monopoly.currentPlayerIndex];
            if (currentPlayer.balance < 0) {
                updateMonopolyStatus(`${currentPlayer.name} has gone bankrupt and is out of the game!`);
                
                monopoly.board.forEach(square => {
                    if (square.owner === currentPlayer.id) {
                        square.owner = null;
                        square.houses = 0;
                    }
                });
                
                monopoly.players = monopoly.players.filter(p => p.id !== currentPlayer.id);
                
                if (monopoly.players.length === 1) {
                    updateMonopolyStatus(`${monopoly.players[0].name} wins Monopoly!`);
                    monopoly.state = 'game_over';
                    DOM.$('#monopoly-roll-dice-button').style.display = 'none';
                    DOM.$('#monopoly-end-turn-button').style.display = 'none';
                } else {
                    if (monopoly.currentPlayerIndex >= monopoly.players.length) {
                        monopoly.currentPlayerIndex = 0;
                    }
                    setTimeout(handleMonopolyTurnLocal, 2000);
                }
            }
        }

        /**
         * Advances to the next player's turn (LOCAL PLAY).
         */
        function nextMonopolyTurnLocal() {
            if (monopoly.state === 'game_over') return;
            monopoly.currentPlayerIndex = (monopoly.currentPlayerIndex + 1) % monopoly.players.length;
            monopoly.state = 'await_roll';
            monopoly.currentProperty = null;
            handleMonopolyTurnLocal();
        }

        /**
         * Implements basic AI logic for a bot player's Monopoly turn (LOCAL PLAY).
         */
        function monopolyBotTurnLocal() {
            const currentPlayer = monopoly.players[monopoly.currentPlayerIndex];
            updateMonopolyStatus(`${currentPlayer.name} (Bot) is thinking...`);

            setTimeout(() => {
                rollMonopolyDice();
            }, 1500);
        }

        // --- PASTE UNO GAME JAVASCRIPT HERE ---

        // ===========================================================================================
        // UNO GAME
        // ===========================================================================================
        const UNO_COLORS = ['red', 'blue', 'green', 'yellow'];
        const UNO_NUMBERS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
        const UNO_SPECIAL_CARDS = ['Skip', 'Reverse', 'Draw Two'];
        const UNO_WILD_CARDS = ['Wild', 'Wild Draw Four'];
        const UNO_INITIAL_HAND_SIZE = 7;

        // let uno = { ... }; // Declared globally

        class UnoCard {
            constructor(color, value) {
                this.color = color;
                this.value = value;
                this.wildColor = null;
            }

            toString() {
                if (this.isWild() && this.wildColor) {
                    return `${this.wildColor} (Wild ${this.value})`;
                }
                return `${this.color} ${this.value}`;
            }

            isWild() {
                return this.color === 'wild';
            }
        }

        /**
         * Creates a standard Uno deck.
         * @returns {Array<UnoCard>} A newly created, unshuffled deck.
         */
        function createUnoDeck() {
            const newDeck = [];
            UNO_COLORS.forEach(color => {
                newDeck.push(new UnoCard(color, '0'));
                for (let i = 1; i <= 9; i++) {
                    newDeck.push(new UnoCard(color, String(i)));
                    newDeck.push(new UnoCard(color, String(i)));
                }
                UNO_SPECIAL_CARDS.forEach(value => {
                    newDeck.push(new UnoCard(color, value));
                    newDeck.push(new UnoCard(color, value));
                });
            });
            for (let i = 0; i < 4; i++) {
                newDeck.push(new UnoCard('wild', 'Wild'));
                newDeck.push(new UnoCard('wild', 'Wild Draw Four'));
            }
            return newDeck;
        }

        /**
         * Shuffles an array of Uno cards.
         * @param {Array<UnoCard>} deck The deck to shuffle.
         * @returns {Array<UnoCard>} The shuffled deck.
         */
        function shuffleUnoDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        /**
         * Initializes a new Uno game (LOCAL PLAY).
         */
        function initUnoGame() {
            uno = { // Reset uno object
                players: [],
                currentPlayerIndex: 0,
                deck: [],
                discardPile: [],
                direction: 1,
                state: 'playing',
                pendingDraw: 0,
                unoDeclared: false,
                lastPlayerToPlay: null
            };

            uno.deck = shuffleUnoDeck(createUnoDeck());
            uno.discardPile = [];

            const initialPlayers = [];
            for (let i = 1; i <= 4; i++) {
                const nameInput = DOM.$(`#uno-player${i}-name`);
                const modeRadios = DOM.$(`input[name="uno-player${i}-mode"]:checked`);
                if (nameInput && nameInput.value && modeRadios && modeRadios.value) {
                    initialPlayers.push({ name: nameInput.value, mode: modeRadios.value });
                }
            }

            if (initialPlayers.length < 2) {
                alert("Uno requires at least 2 players. Please set up more players.");
                showGameSetup('uno', 'local');
                return;
            }

            const UNO_PLAYER_COLORS = ['red', 'blue', 'green', 'yellow'];
            initialPlayers.forEach((p, i) => {
                uno.players.push({
                    id: `p${i + 1}`,
                    name: p.name,
                    mode: p.mode,
                    hand: [],
                    color: UNO_PLAYER_COLORS[i]
                });
            });

            uno.players.forEach(player => {
                for (let i = 0; i < UNO_INITIAL_HAND_SIZE; i++) {
                    const card = drawUnoCardFromDeckLocal(null);
                    if (card) player.hand.push(card);
                }
            });

            let startCard;
            do {
                startCard = drawUnoCardFromDeckLocal(null);
                if (startCard && startCard.isWild()) {
                    uno.deck.push(startCard);
                    uno.deck = shuffleUnoDeck(uno.deck);
                }
            } while (!startCard || startCard.isWild());
            
            if (startCard) {
                uno.discardPile.push(startCard);
            } else {
                updateUnoStatus("Error: Could not start game with a valid card in deck.");
                return;
            }

            renderUnoGame();
            updateUnoStatus(`${uno.players[uno.currentPlayerIndex].name}'s turn.`);
            handleUnoTurnLocal();
        }

        /**
         * Renders the entire Uno game interface.
         */
        function renderUnoGame() {
            const discardPileEl = DOM.$('#uno-discard-pile');
            discardPileEl.innerHTML = '';
            if (uno.discardPile.length > 0) {
                const topCard = uno.discardPile[uno.discardPile.length - 1];
                const cardEl = createUnoCardElement(topCard, false);
                cardEl.style.transform = `rotate(${(Math.random() * 20) - 10}deg)`;
                discardPileEl.appendChild(cardEl);
            } else {
                discardPileEl.textContent = 'Discard Pile';
            }

            const drawPileEl = DOM.$('#uno-draw-pile');
            drawPileEl.textContent = `Draw Pile (${uno.deck.length})`;
            drawPileEl.classList.toggle('active', (currentPlayMode === 'online' && myClientId === uno.players[uno.currentPlayerIndex]?.id && (uno.state === 'playing' || (uno.state === 'pending_draw_action' && uno.pendingDraw > 0))) || (currentPlayMode === 'local' && (uno.state === 'playing' || (uno.state === 'pending_draw_action' && uno.pendingDraw > 0))) );

            const currentPlayer = uno.players[uno.currentPlayerIndex];
            const handEl = DOM.$('#uno-current-player-hand');
            handEl.innerHTML = '';

            if (currentPlayer && (currentPlayMode === 'local' || myClientId === currentPlayer.id)) { // Only show current player's hand (or my hand if online)
                currentPlayer.hand.forEach((card, index) => {
                    const cardEl = createUnoCardElement(card, true);
                    cardEl.dataset.handIndex = index;
                    if (currentPlayMode === 'online') {
                        cardEl.onclick = () => sendUnoPlayCard(card, index);
                    } else {
                        cardEl.onclick = () => playUnoCard(card, index); // Local play function
                    }
                    handEl.appendChild(cardEl);
                });
            } else {
                // If not current player's hand in online mode, show back of cards
                handEl.innerHTML = `<p>Not your turn or not your hand. ${currentPlayer ? currentPlayer.name : 'Another player'}'s turn.</p>`;
                const numCards = currentPlayer ? currentPlayer.hand.length : 0;
                for(let i=0; i<numCards; i++) {
                    const backCard = DOM.create('div', ['uno-card', 'back-of-card']); // Apply special style for back
                    handEl.appendChild(backCard);
                }
            }


            if (currentPlayMode === 'local' || (currentPlayMode === 'online' && myClientId === currentPlayer.id)) {
                const topCard = uno.discardPile[uno.discardPile.length - 1];
                const isDrawActionPending = uno.pendingDraw > 0;
                
                currentPlayer.hand.forEach((card, index) => {
                    const cardEl = handEl.querySelector(`[data-hand-index="${index}"]`);
                    if (!cardEl) return; // May not exist if hand is not fully rendered for non-current player

                    let canPlay = false;

                    if (isDrawActionPending) {
                        if ((card.value === topCard.value && card.value === 'Draw Two') || card.value === 'Wild Draw Four') {
                            canPlay = true;
                        } else if (card.value === 'Wild Draw Four') {
                            canPlay = true;
                        }
                    } else {
                        canPlay = isValidUnoPlay(card);
                    }

                    if (canPlay) {
                        cardEl.classList.add('active');
                        cardEl.classList.remove('disabled');
                    } else {
                        cardEl.classList.remove('active');
                        cardEl.classList.add('disabled');
                    }
                });
            }


            const playerInfoEl = DOM.$('#uno-player-info');
            playerInfoEl.innerHTML = '';
            uno.players.forEach((player, index) => {
                const playerCard = DOM.create('div', ['player-card']);
                playerCard.classList.toggle('current-player', index === uno.currentPlayerIndex);
                playerCard.innerHTML = `<h4>${player.name} <span style="color:${player.color};">‚óè</span></h4><p>Cards: ${player.hand.length}</p>`;
                playerInfoEl.appendChild(playerCard);
            });

            const isMyTurn = (currentPlayMode === 'online' && myClientId === currentPlayer.id) || currentPlayMode === 'local';
            DOM.$('#uno-declare-button').style.display = isMyTurn && currentPlayer.hand.length === 2 && !uno.unoDeclared ? 'block' : 'none';
            DOM.$('#uno-declare-button').classList.toggle('active', currentPlayer.hand.length === 2);

            const endDrawTurnBtn = DOM.$('#uno-end-draw-turn-button');
            if (endDrawTurnBtn) {
                if (isMyTurn && uno.state === 'await_draw_decision') {
                    endDrawTurnBtn.style.display = 'block';
                } else {
                    endDrawTurnBtn.style.display = 'none';
                }
            }
             // Hide color picker if not active or not my turn
            if (uno.state !== 'color_select' || !isMyTurn) {
                DOM.$('#uno-color-picker').style.display = 'none';
            }
        }

        /**
         * Creates a DOM element for an Uno card.
         * @param {UnoCard} card The UnoCard object.
         * @param {boolean} interactive True if the card should be clickable (e.g., in a hand).
         * @returns {HTMLElement} The card's DOM element.
         */
        function createUnoCardElement(card, interactive) {
            const cardEl = DOM.create('div', ['uno-card', card.color]);
            cardEl.dataset.cardColor = card.color;
            cardEl.dataset.cardValue = card.value;

            if (card.isWild()) {
                if (card.wildColor) {
                    cardEl.style.backgroundImage = 'none';
                    cardEl.style.backgroundColor = card.wildColor;
                    cardEl.innerHTML = `<div class="card-value">${card.value.replace('Wild ', '+')}</div>`;
                    cardEl.innerHTML += `<div class="card-color-indicator" style="color:rgba(0,0,0,0.5);">${card.wildColor}</div>`;
                } else {
                     cardEl.innerHTML = `<div class="card-value">${card.value.replace('Wild ', '+')}</div>`;
                }
            } else {
                cardEl.innerHTML = `<div class="card-value">${card.value}</div>`;
            }
            if (!interactive) {
                cardEl.style.cursor = 'default';
            }
            return cardEl;
        }

        /**
         * Draws cards from the deck (LOCAL PLAY).
         * @param {object|null} player The player to draw for.
         * @param {number} count Number of cards to draw.
         * @returns {UnoCard|Array<UnoCard>|null} The drawn card(s) or null if unable to draw.
         */
        function drawUnoCardFromDeckLocal(player, count = 1) {
            const drawnCards = [];
            for (let i = 0; i < count; i++) {
                if (uno.deck.length === 0) {
                    if (uno.discardPile.length <= 1) {
                        updateUnoStatus("Not enough cards to draw. Game might be stuck.");
                        return null;
                    }
                    const topCard = uno.discardPile.pop();
                    uno.deck = shuffleUnoDeck(uno.discardPile);
                    uno.discardPile = [topCard];
                    updateUnoStatus("Shuffling discard pile into new deck.");
                }
                if (uno.deck.length > 0) {
                    const card = uno.deck.pop();
                    if (card.isWild()) card.wildColor = null;
                    drawnCards.push(card);
                } else {
                    updateUnoStatus("No cards left to draw from deck or discard pile.");
                    break;
                }
            }
            
            if (drawnCards.length > 0 && player) {
                player.hand.push(...drawnCards);
            }
            return drawnCards.length === 1 ? drawnCards[0] : drawnCards;
        }

        /**
         * Checks if a given card is valid to play on the current discard pile.
         * @param {UnoCard} card The card to check.
         * @returns {boolean} True if the card can be played, false otherwise.
         */
        function isValidUnoPlay(card) {
            const topCard = uno.discardPile[uno.discardPile.length - 1];
            const matchColor = topCard.isWild() && topCard.wildColor ? topCard.wildColor : topCard.color;

            if (card.isWild()) {
                return true;
            }
            return card.color === matchColor || card.value === topCard.value;
        }

        /**
         * Handles a player attempting to play a card (LOCAL PLAY).
         * @param {UnoCard} cardToPlay The card object to play.
         * @param {number} handIndex The index of the card in the player's hand.
         */
        function playUnoCard(cardToPlay, handIndex) { // LOCAL PLAY
            const currentPlayer = uno.players[uno.currentPlayerIndex];
            if (currentPlayer.mode === 'bot') return;

            if (uno.pendingDraw > 0) {
                const topCard = uno.discardPile[uno.discardPile.length - 1];
                if ((cardToPlay.value === 'Draw Two' && topCard.value === 'Draw Two') || 
                    (cardToPlay.value === 'Wild Draw Four')) {
                } else {
                    updateUnoStatus(`${currentPlayer.name}, you must draw ${uno.pendingDraw} cards first or play a matching Draw card.`);
                    return;
                }
            }

            if (!isValidUnoPlay(cardToPlay) && uno.pendingDraw === 0) {
                updateUnoStatus(`Cannot play ${cardToPlay.toString()}. Match color, number, or play a Wild card.`);
                return;
            }

            const playedCard = currentPlayer.hand.splice(handIndex, 1)[0];
            
            if (uno.discardPile.length > 0 && uno.discardPile[uno.discardPile.length - 1].isWild()) {
                uno.discardPile[uno.discardPile.length - 1].wildColor = null;
            }

            uno.discardPile.push(playedCard);
            uno.lastPlayerToPlay = currentPlayer.id;
            updateUnoStatus(`${currentPlayer.name} played a ${playedCard.toString()}.`);

            if (currentPlayer.hand.length === 1 && !uno.unoDeclared) {
                updateUnoStatus(`${currentPlayer.name} did not declare UNO! Drawing 2 cards as penalty.`);
                drawUnoCardFromDeckLocal(currentPlayer, 2);
            }
            uno.unoDeclared = false;

            if (playedCard.isWild()) {
                uno.state = 'color_select';
                showUnoColorPicker(playedCard.value);
                if (playedCard.value === 'Wild Draw Four') {
                    uno.pendingDraw += 4;
                }
                return;
            } else if (playedCard.value === 'Skip') {
                updateUnoStatus("Skip card played! Next player is skipped.");
                nextUnoTurnLocal(true);
            } else if (playedCard.value === 'Reverse') {
                uno.direction *= -1;
                updateUnoStatus("Reverse card played! Direction changed.");
                if (uno.players.length === 2) {
                    nextUnoTurnLocal(true);
                } else {
                    nextUnoTurnLocal();
                }
            } else if (playedCard.value === 'Draw Two') {
                uno.pendingDraw += 2;
                updateUnoStatus("Draw Two card played! Next player must draw 2.");
                nextUnoTurnLocal();
            } else {
                nextUnoTurnLocal();
            }

            checkUnoWinLocal();
        }

        /**
         * Handles the selection of a color after a Wild card is played (LOCAL PLAY).
         * @param {string} color The chosen color.
         */
        function selectUnoWildColor(color) { // LOCAL PLAY
            const wildCard = uno.discardPile[uno.discardPile.length - 1];
            if (wildCard.isWild()) {
                wildCard.wildColor = color;
                updateUnoStatus(`Wild color changed to ${color}.`);
            }
            DOM.$('#uno-color-picker').style.display = 'none';
            uno.state = 'playing';

            if (uno.pendingDraw > 0) {
                 const nextPlayerIndex = (uno.currentPlayerIndex + uno.direction + uno.players.length) % uno.players.length;
                 const nextPlayer = uno.players[nextPlayerIndex];
                 drawUnoCardFromDeckLocal(nextPlayer, uno.pendingDraw);
                 updateUnoStatus(`${nextPlayer.name} drew ${uno.pendingDraw} cards due to action card.`);
                 uno.pendingDraw = 0;
            }
            
            nextUnoTurnLocal();
            checkUnoWinLocal();
        }

        /**
         * Displays the color picker when a Wild card is played.
         * @param {string} cardValue The value of the wild card.
         */
        function showUnoColorPicker(cardValue) {
            const picker = DOM.$('#uno-color-picker');
            picker.style.display = 'flex';
            updateUnoStatus(`${uno.players[uno.currentPlayerIndex].name}, select a new color for the ${cardValue} card.`);
        }

        /**
         * Handles a player declaring "UNO!" (LOCAL PLAY).
         */
        function declareUno() { // LOCAL PLAY
            const currentPlayer = uno.players[uno.currentPlayerIndex];
            if (currentPlayer.hand.length === 1) {
                uno.unoDeclared = true;
                updateUnoStatus(`${currentPlayer.name} declared UNO!`);
                DOM.$('#uno-declare-button').style.display = 'none';
            } else {
                updateUnoStatus("You can only declare UNO when you have one card left!");
            }
        }

        /**
         * Advances to the next player's turn (LOCAL PLAY).
         * @param {boolean} skip True if the next player should be skipped.
         */
        function nextUnoTurnLocal(skip = false) {
            if (uno.state === 'game_over') return;
            
            const endDrawTurnBtn = DOM.$('#uno-end-draw-turn-button');
            if (endDrawTurnBtn) endDrawTurnBtn.style.display = 'none';

            let playerIndex = uno.currentPlayerIndex;
            playerIndex = (playerIndex + uno.direction + uno.players.length) % uno.players.length;
            if (skip) {
                playerIndex = (playerIndex + uno.direction + uno.players.length) % uno.players.length;
            }
            uno.currentPlayerIndex = playerIndex;
            uno.state = 'playing';

            const currentPlayer = uno.players[uno.currentPlayerIndex];
            updateUnoStatus(`${currentPlayer.name}'s turn.`);
            renderUnoGame();

            if (currentPlayer.mode === 'bot') {
                setTimeout(unoBotTurnLocal, 1500);
            }
        }

        /**
         * Implements basic AI logic for a bot player's Uno turn (LOCAL PLAY).
         */
        function unoBotTurnLocal() {
            const currentPlayer = uno.players[uno.currentPlayerIndex];
            updateUnoStatus(`${currentPlayer.name} (Bot) is thinking...`);

            setTimeout(() => {
                if (uno.pendingDraw > 0) {
                    const topCard = uno.discardPile[uno.discardPile.length - 1];
                    const playableDrawCards = currentPlayer.hand.map((card, index) => ({card, index}))
                        .filter(item => (item.card.value === 'Draw Two' && topCard.value === 'Draw Two') || item.card.value === 'Wild Draw Four');

                    if (playableDrawCards.length > 0) {
                        const cardToPlayItem = playableDrawCards[0];
                        if (currentPlayer.hand.length === 2 && !uno.unoDeclared) {
                            declareUno();
                        }
                        playUnoCard(cardToPlayItem.card, cardToPlayItem.index);
                        if (cardToPlayItem.card.isWild()) {
                            botChooseUnoWildColorLocal(currentPlayer);
                        }
                    } else {
                        const drawn = drawUnoCardFromDeckLocal(currentPlayer, uno.pendingDraw);
                        if (drawn) {
                            uno.pendingDraw = 0;
                            updateUnoStatus(`${currentPlayer.name} (Bot) drew ${Array.isArray(drawn) ? drawn.length : 1} cards due to action. Turn ends.`);
                            renderUnoGame();
                            nextUnoTurnLocal();
                        }
                    }
                    return;
                }

                const playableCards = currentPlayer.hand.map((card, index) => ({card, index})).filter(item => isValidUnoPlay(item.card));
                let cardToPlayItem = null;

                if (playableCards.length > 0) {
                    cardToPlayItem = playableCards.find(item => UNO_SPECIAL_CARDS.includes(item.card.value) && !item.card.isWild());
                    
                    if (!cardToPlayItem) {
                        cardToPlayItem = playableCards.find(item => UNO_NUMBERS.includes(item.card.value) && !item.card.isWild());
                    }

                    if (!cardToPlayItem) {
                        cardToPlayItem = playableCards.find(item => item.card.value === 'Wild');
                    }
                    if (!cardToPlayItem) {
                        cardToPlayItem = playableCards.find(item => item.card.value === 'Wild Draw Four');
                    }
                }

                if (cardToPlayItem) {
                    if (currentPlayer.hand.length === 2 && !uno.unoDeclared) {
                        declareUno();
                    }
                    playUnoCard(cardToPlayItem.card, cardToPlayItem.index);

                    if (cardToPlayItem.card.isWild()) {
                        botChooseUnoWildColorLocal(currentPlayer);
                    }
                } else {
                    const drawnCard = drawUnoCardFromDeckLocal(currentPlayer);
                    updateUnoStatus(`${currentPlayer.name} (Bot) drew a card.`);
                    
                    if (drawnCard && !Array.isArray(drawnCard) && isValidUnoPlay(drawnCard)) {
                        const newCardIndex = currentPlayer.hand.length - 1; 
                        playUnoCard(drawnCard, newCardIndex);
                         if (drawnCard.isWild()) {
                             botChooseUnoWildColorLocal(currentPlayer);
                         }
                    } else {
                        updateUnoStatus(`${currentPlayer.name} (Bot)'s turn ends.`);
                        renderUnoGame();
                        nextUnoTurnLocal();
                    }
                }
            }, 1500);
        }

        /**
         * Bot logic for choosing a wild card color (LOCAL PLAY).
         * @param {object} currentPlayer The bot player.
         */
        function botChooseUnoWildColorLocal(currentPlayer) {
            const colorCounts = { 'red': 0, 'blue': 0, 'green': 0, 'yellow': 0 };
            currentPlayer.hand.forEach(card => {
                if (UNO_COLORS.includes(card.color)) {
                    colorCounts[card.color]++;
                }
            });
            let chosenColor = UNO_COLORS[Math.floor(Math.random() * UNO_COLORS.length)];
            let maxCount = -1;
            for (const color in colorCounts) {
                if (colorCounts[color] > maxCount) {
                    maxCount = colorCounts[color];
                    chosenColor = color;
                }
            }
            selectUnoWildColor(chosenColor);
        }

        /**
         * Checks for Uno win condition (player has no cards left) (LOCAL PLAY).
         */
        function checkUnoWinLocal() {
            const currentPlayer = uno.players[uno.currentPlayerIndex];
            if (currentPlayer.hand.length === 0) {
                updateUnoStatus(`${currentPlayer.name} wins the Uno game!`);
                uno.state = 'game_over';
                DOM.$('#uno-declare-button').style.display = 'none';
                DOM.$('#uno-color-picker').style.display = 'none';
                DOM.$('#uno-draw-pile').onclick = null;
                const endDrawTurnBtn = DOM.$('#uno-end-draw-turn-button');
                if (endDrawTurnBtn) endDrawTurnBtn.style.display = 'none';
            }
        }

        // --- PASTE CHESS GAME JAVASCRIPT HERE ---

        // ===========================================================================================
        // CHESS GAME (Advanced Simplified)
        // ===========================================================================================

        const CHESS_BOARD_SIZE = 8;
        const CHESS_PIECE_SYMBOLS = {
            'R': '‚ôú', 'N': '‚ôû', 'B': '‚ôù', 'Q': '‚ôõ', 'K': '‚ôö', 'P': '‚ôü', // Black unicode for black pieces
            'r': '‚ôñ', 'n': '‚ôò', 'b': '‚ôó', 'q': '‚ôï', 'k': '‚ôî', 'p': '‚ôô'  // White unicode for white pieces
        };
        const CHESS_STARTING_BOARD_FEN = [
            ['bR', 'bN', 'bB', 'bQ', 'bK', 'bB', 'bN', 'bR'],
            ['bP', 'bP', 'bP', 'bP', 'bP', 'bP', 'bP', 'bP'],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            ['wP', 'wP', 'wP', 'wP', 'wP', 'wP', 'wP', 'wP'],
            ['wR', 'wN', 'wB', 'wQ', 'wK', 'wB', 'wN', 'wR']
        ];

        // let chess = { ... }; // Declared globally

        /**
         * Initializes a new Chess game (LOCAL PLAY).
         */
        function initChessGame() {
            chess = { // Reset chess object
                players: [],
                board: [],
                currentPlayerIndex: 0,
                selectedPiece: null,
                state: 'playing'
            };

            const player1Name = DOM.$('#chess-player1-name').value || 'White Player';
            const player1Mode = DOM.$(`input[name="chess-player1-mode"]:checked`).value;
            const player2Name = DOM.$('#chess-player2-name').value || 'Black Player';
            const player2Mode = DOM.$(`input[name="chess-player2-mode"]:checked`).value;

            chess.players.push({ id: 'white', name: player1Name, mode: player1Mode, color: 'white' });
            chess.players.push({ id: 'black', name: player2Name, mode: player2Mode, color: 'black' });

            chess.board = CHESS_STARTING_BOARD_FEN.map(row => [...row]);

            renderChessBoard();
            updateChessStatus(`${chess.players[chess.currentPlayerIndex].name}'s turn (White).`);
            handleChessTurnLocal();
        }

        /**
         * Renders the Chess board, including pieces and highlights.
         */
        function renderChessBoard() {
            const boardEl = DOM.$('#chess-board');
            boardEl.innerHTML = '';

            for (let r = 0; r < CHESS_BOARD_SIZE; r++) {
                for (let c = 0; c < CHESS_BOARD_SIZE; c++) {
                    const cell = DOM.create('div', ['chess-cell', ((r + c) % 2 === 0) ? 'light' : 'dark']);
                    cell.dataset.row = r;
                    cell.dataset.col = c;

                    // Dynamically assign onclick based on play mode
                    if (currentPlayMode === 'online') {
                        cell.onclick = () => handleChessClickOnline({ r, c });
                    } else {
                        cell.onclick = () => handleChessClickLocal({ r, c });
                    }

                    const pieceCode = chess.board[r][c];
                    if (pieceCode) {
                        const pieceColor = pieceCode[0] === 'w' ? 'white' : 'black';
                        const symbolKey = pieceCode[0] === 'w' ? pieceCode[1].toLowerCase() : pieceCode[1];
                        const symbol = CHESS_PIECE_SYMBOLS[symbolKey];
                        const pieceEl = DOM.create('div', ['chess-piece', pieceColor], symbol);
                        cell.appendChild(pieceEl);
                    }
                    boardEl.appendChild(cell);
                }
            }

            if (chess.selectedPiece) {
                const { r, c } = chess.selectedPiece;
                const cell = DOM.$(`[data-row="${r}"][data-col="${c}"]`);
                if (cell) cell.classList.add('selected');

                const legalMoves = getLegalChessMoves(r, c, chess.board);
                legalMoves.forEach(move => {
                    const targetCell = DOM.$(`[data-row="${move.r}"][data-col="${move.c}"]`);
                    if (targetCell) {
                        if (chess.board[move.r][move.c]) {
                            targetCell.classList.add('highlight-capture');
                        } else {
                            if (!targetCell.querySelector('.highlight-move')) {
                                const highlightDot = DOM.create('div', ['highlight-move']);
                                targetCell.appendChild(highlightDot);
                            }
                        }
                    }
                });
            }
        }

        /**
         * Updates the Chess game status message.
         * @param {string} message The message to display.
         */
        function updateChessStatus(message) {
            DOM.$('#chess-status').textContent = message;
        }

        /**
         * Manages the current player's turn (LOCAL PLAY).
         */
        function handleChessTurnLocal() {
            if (chess.state === 'game_over') return;

            const currentPlayer = chess.players[chess.currentPlayerIndex];
            DOM.$('#chess-current-player-name').textContent = currentPlayer.name;

            const allLegalMoves = getAllLegalChessMoves(chess.board, currentPlayer.id[0]);
            const isCurrentPlayerInCheck = isKingInCheck(chess.board, currentPlayer.id[0]);

            if (allLegalMoves.length === 0) {
                if (isCurrentPlayerInCheck) {
                    updateChessStatus(`${currentPlayer.name} is in CHECKMATE! ${chess.players[(chess.currentPlayerIndex + 1) % 2].name} wins!`);
                } else {
                    updateChessStatus(`STALEMATE! ${currentPlayer.name} has no legal moves.`);
                }
                chess.state = 'game_over';
                return;
            }

            if (isCurrentPlayerInCheck) {
                updateChessStatus(`${currentPlayer.name}'s turn. You are in CHECK!`);
            } else {
                updateChessStatus(`${currentPlayer.name}'s turn.`);
            }


            if (currentPlayer.mode === 'bot') {
                setTimeout(chessBotTurnLocal, 1000);
            }
        }

        /**
         * Handles user clicks on the Chess board (LOCAL PLAY).
         * @param {{r: number, c: number}} param0 The row and column of the clicked cell.
         */
        function handleChessClickLocal({ r, c }) {
            if (chess.state !== 'playing' || chess.players[chess.currentPlayerIndex].mode === 'bot') return;

            const pieceCode = chess.board[r][c];
            const currentPlayerColor = chess.players[chess.currentPlayerIndex].id[0];

            if (chess.selectedPiece) {
                const { r: sr, c: sc } = chess.selectedPiece;
                const legalMoves = getLegalChessMoves(sr, sc, chess.board);
                const isValidMove = legalMoves.some(move => move.r === r && move.c === c);

                if (isValidMove) {
                    moveChessPieceLocal(sr, sc, r, c);
                } else {
                    chess.selectedPiece = null;
                    renderChessBoard();
                    updateChessStatus(`${chess.players[chess.currentPlayerIndex].name}'s turn. Invalid move or deselected. Try again.`);
                    if (pieceCode && getPieceColor(pieceCode) === currentPlayerColor) {
                        chess.selectedPiece = { r, c, piece: pieceCode };
                        renderChessBoard();
                    }
                }
            } else {
                if (pieceCode && getPieceColor(pieceCode) === currentPlayerColor) {
                    chess.selectedPiece = { r, c, piece: pieceCode };
                    renderChessBoard();
                    updateChessStatus(`${chess.players[chess.currentPlayerIndex].name}'s turn. Selected ${getPieceType(pieceCode)} at (${r}, ${c}).`);
                } else if (pieceCode) {
                    updateChessStatus(`${chess.players[chess.currentPlayerIndex].name}'s turn. That's not your piece!`);
                } else {
                    updateChessStatus(`${chess.players[chess.currentPlayerIndex].name}'s turn. Select a piece to move.`);
                }
            }
        }

        /**
         * Executes a Chess piece movement (LOCAL PLAY).
         * @param {number} sr Source row.
         * @param {number} sc Source column.
         * @param {number} tr Target row.
         * @param {number} tc Target column.
         */
        function moveChessPieceLocal(sr, sc, tr, tc) {
            const pieceCode = chess.board[sr][sc];
            const pieceColor = getPieceColor(pieceCode);
            const pieceType = getPieceType(pieceCode);
            const capturedPiece = chess.board[tr][tc];

            chess.board[tr][tc] = pieceCode;
            chess.board[sr][sc] = null;
            chess.selectedPiece = null;

            updateChessStatus(`${chess.players[chess.currentPlayerIndex].name} moved ${pieceType} from (${sr}, ${sc}) to (${tr}, ${tc}).`);
            if (capturedPiece) {
                updateChessStatus(`... and captured ${getPieceType(capturedPiece)}!`);
            }

            if (pieceType === 'P' && ((pieceColor === 'w' && tr === 0) || (pieceColor === 'b' && tr === 7))) {
                handlePawnPromotionLocal(tr, tc, pieceColor);
                return;
            }

            const opponentKingCode = (pieceColor === 'w') ? 'bK' : 'wK';
            let opponentKingFound = false;
            for (let r = 0; r < CHESS_BOARD_SIZE; r++) {
                for (let c = 0; c < CHESS_BOARD_SIZE; c++) {
                    if (chess.board[r][c] === opponentKingCode) {
                        opponentKingFound = true;
                        break;
                    }
                }
                if (opponentKingFound) break;
            }

            if (!opponentKingFound) {
                updateChessStatus(`${chess.players[chess.currentPlayerIndex].name} wins! King captured!`);
                chess.state = 'game_over';
            } else {
                nextChessTurnLocal();
            }
        }

        /**
         * Handles pawn promotion when a pawn reaches the last rank (LOCAL PLAY).
         * @param {number} r Row.
         * @param {number} c Column.
         * @param {string} color Color.
         */
        function handlePawnPromotionLocal(r, c, color) {
            const currentPlayer = chess.players[chess.currentPlayerIndex];
            if (currentPlayer.mode === 'bot') {
                chess.board[r][c] = color + 'Q';
                updateChessStatus(`${currentPlayer.name}'s pawn promoted to Queen!`);
                renderChessBoard();
                nextChessTurnLocal();
            } else {
                let promotionChoice = null;
                do {
                    promotionChoice = prompt("Pawn Promotion! Enter 'Q' for Queen.", 'Q');
                    if (promotionChoice === null) {
                        promotionChoice = 'Q';
                        break;
                    }
                    promotionChoice = promotionChoice.toUpperCase();
                } while (promotionChoice !== 'Q');
                
                chess.board[r][c] = color + promotionChoice;
                updateChessStatus(`${currentPlayer.name}'s pawn promoted to ${promotionChoice}!`);
                renderChessBoard();
                nextChessTurnLocal();
            }
        }


        /**
         * Advances to the next player's turn (LOCAL PLAY).
         */
        function nextChessTurnLocal() {
            if (chess.state === 'game_over') return;
            chess.currentPlayerIndex = (chess.currentPlayerIndex + 1) % chess.players.length;
            renderChessBoard();
            handleChessTurnLocal();
        }

        // --- CHESS PIECE MOVEMENT LOGIC & CHECK DETECTION (Shared) ---
        // These are helper functions used by both local and online logic

        /**
         * Gets the color of a piece code ('w' or 'b').
         */
        function getPieceColor(pieceCode) {
            return pieceCode ? pieceCode[0] : null;
        }

        /**
         * Gets the type of a piece code ('P', 'R', 'N', etc.).
         */
        function getPieceType(pieceCode) {
            return pieceCode ? pieceCode[1] : null;
        }

        /**
         * Finds the current position of the King of a specific color on a given board state.
         */
        function findKingPosition(boardState, kingColor) {
            const kingCode = kingColor + 'K';
            for (let r = 0; r < CHESS_BOARD_SIZE; r++) {
                for (let c = 0; c < CHESS_BOARD_SIZE; c++) {
                    if (boardState[r][c] === kingCode) {
                        return { r, c };
                    }
                }
            }
            return null;
        }

        /**
         * Checks if a specific square on a given board state is attacked by a given attacking color.
         */
        function isSquareAttacked(boardState, r, c, attackingColor) {
            const opponentColor = attackingColor; 

            // 1. Check for Pawn attacks
            const pawnDirection = (opponentColor === 'w') ? -1 : 1;
            const pawnAttackOffsets = [
                { dr: pawnDirection, dc: -1 },
                { dr: pawnDirection, dc: 1 }
            ];
            for (const { dr, dc } of pawnAttackOffsets) {
                const pr = r + dr;
                const pc = c + dc;
                if (pr >= 0 && pr < CHESS_BOARD_SIZE && pc >= 0 && pc < CHESS_BOARD_SIZE) {
                    const piece = boardState[pr][pc];
                    if (piece && getPieceColor(piece) === opponentColor && getPieceType(piece) === 'P') {
                        return true;
                    }
                }
            }

            // 2. Check for Knight attacks
            const knightMoves = [
                [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                [1, -2], [1, 2], [2, -1], [2, 1]
            ];
            for (const [dr, dc] of knightMoves) {
                const nr = r + dr;
                const nc = c + dc;
                if (nr >= 0 && nr < CHESS_BOARD_SIZE && nc >= 0 && nc < CHESS_BOARD_SIZE) {
                    const piece = boardState[nr][nc];
                    if (piece && getPieceColor(piece) === opponentColor && getPieceType(piece) === 'N') {
                        return true;
                    }
                }
            }

            // 3. Check for Rook/Queen (straight line) attacks
            const straightDirections = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            for (const [dr, dc] of straightDirections) {
                for (let i = 1; i < CHESS_BOARD_SIZE; i++) {
                    const tr = r + dr * i;
                    const tc = c + dc * i;
                    if (tr < 0 || tr >= CHESS_BOARD_SIZE || tc < 0 || tc >= CHESS_BOARD_SIZE) break;
                    const piece = boardState[tr][tc];
                    if (piece) {
                        if (getPieceColor(piece) === opponentColor && (getPieceType(piece) === 'R' || getPieceType(piece) === 'Q')) {
                            return true;
                        }
                        break;
                    }
                }
            }

            // 4. Check for Bishop/Queen (diagonal line) attacks
            const diagonalDirections = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
            for (const [dr, dc] of diagonalDirections) {
                for (let i = 1; i < CHESS_BOARD_SIZE; i++) {
                    const tr = r + dr * i;
                    const tc = c + dc * i;
                    if (tr < 0 || tr >= CHESS_BOARD_SIZE || tc < 0 || tc >= CHESS_BOARD_SIZE) break;
                    const piece = boardState[tr][tc];
                    if (piece) {
                        if (getPieceColor(piece) === opponentColor && (getPieceType(piece) === 'B' || getPieceType(piece) === 'Q')) {
                            return true;
                        }
                        break;
                    }
                }
            }

            // 5. Check for King attacks (adjacent to opponent King)
            const kingMoves = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1],           [0, 1],
                [1, -1], [1, 0], [1, 1]
            ];
            for (const [dr, dc] of kingMoves) {
                const kr = r + dr;
                const kc = c + dc;
                if (kr >= 0 && kr < CHESS_BOARD_SIZE && kc >= 0 && kc < CHESS_BOARD_SIZE) {
                    const piece = boardState[kr][kc];
                    if (piece && getPieceColor(piece) === opponentColor && getPieceType(piece) === 'K') {
                        return true;
                    }
                }
            }

            return false;
        }


        /**
         * Checks if the King of a specific color is currently in check on a given board state.
         */
        function isKingInCheck(boardState, kingColor) {
            const kingPos = findKingPosition(boardState, kingColor);
            if (!kingPos) return false;

            const attackingColor = (kingColor === 'w') ? 'b' : 'w';
            return isSquareAttacked(boardState, kingPos.r, kingPos.c, attackingColor);
        }

        /**
         * Calculates all pseudo-legal moves for a piece at a given position on a given board state.
         */
        function getPseudoLegalMoves(boardState, r, c) {
            const pieceCode = boardState[r][c];
            if (!pieceCode) return [];

            const color = getPieceColor(pieceCode);
            const type = getPieceType(pieceCode);
            const moves = [];

            function addMove(tr, tc) {
                if (tr >= 0 && tr < CHESS_BOARD_SIZE && tc >= 0 && tc < CHESS_BOARD_SIZE) {
                    const targetPiece = boardState[tr][tc];
                    if (!targetPiece || getPieceColor(targetPiece) !== color) {
                        moves.push({ r: tr, c: tc });
                    }
                }
            }

            switch (type) {
                case 'P': // Pawn
                    const direction = (color === 'w') ? -1 : 1;
                    const startRow = (color === 'w') ? 6 : 1;

                    // Forward 1
                    if (r + direction >= 0 && r + direction < CHESS_BOARD_SIZE && !boardState[r + direction][c]) {
                        addMove(r + direction, c);
                    }
                    // Forward 2 from start
                    if (r === startRow && !boardState[r + direction][c] && !boardState[r + 2 * direction][c]) {
                        addMove(r + 2 * direction, c);
                    }
                    // Captures (diagonal)
                    if (c > 0 && r + direction >= 0 && r + direction < CHESS_BOARD_SIZE && boardState[r + direction][c - 1] && getPieceColor(boardState[r + direction][c - 1]) !== color) {
                        addMove(r + direction, c - 1);
                    }
                    if (c < CHESS_BOARD_SIZE - 1 && r + direction >= 0 && r + direction < CHESS_BOARD_SIZE && boardState[r + direction][c + 1] && getPieceColor(boardState[r + direction][c + 1]) !== color) {
                        addMove(r + direction, c + 1);
                    }
                    break;

                case 'R': // Rook
                    const rookDirections = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                    rookDirections.forEach(([dr, dc]) => {
                        for (let i = 1; i < CHESS_BOARD_SIZE; i++) {
                            const tr = r + dr * i;
                            const tc = c + dc * i;
                            if (tr < 0 || tr >= CHESS_BOARD_SIZE || tc < 0 || tc >= CHESS_BOARD_SIZE) break;
                            const targetPiece = boardState[tr][tc];
                            if (!targetPiece) {
                                addMove(tr, tc);
                            } else {
                                if (getPieceColor(targetPiece) !== color) addMove(tr, tc);
                                break;
                            }
                        }
                    });
                    break;

                case 'N': // Knight
                    const knightMoves = [
                        [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                        [1, -2], [1, 2], [2, -1], [2, 1]
                    ];
                    knightMoves.forEach(([dr, dc]) => addMove(r + dr, c + dc));
                    break;

                case 'B': // Bishop
                    const bishopDirections = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                    bishopDirections.forEach(([dr, dc]) => {
                        for (let i = 1; i < CHESS_BOARD_SIZE; i++) {
                            const tr = r + dr * i;
                            const tc = c + dc * i;
                            if (tr < 0 || tr >= CHESS_BOARD_SIZE || tc < 0 || tc >= CHESS_BOARD_SIZE) break;
                            const targetPiece = boardState[tr][tc];
                            if (!targetPiece) {
                                addMove(tr, tc);
                            } else {
                                if (getPieceColor(targetPiece) !== color) addMove(tr, tc);
                                break;
                            }
                        }
                    });
                    break;

                case 'Q': // Queen (Rook + Bishop)
                    const queenDirections = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]];
                    queenDirections.forEach(([dr, dc]) => {
                        for (let i = 1; i < CHESS_BOARD_SIZE; i++) {
                            const tr = r + dr * i;
                            const tc = c + dc * i;
                            if (tr < 0 || tr >= CHESS_BOARD_SIZE || tc < 0 || tc >= CHESS_BOARD_SIZE) break;
                            const targetPiece = boardState[tr][tc];
                            if (!targetPiece) {
                                addMove(tr, tc);
                            } else {
                                if (getPieceColor(targetPiece) !== color) addMove(tr, tc);
                                break;
                            }
                        }
                    });
                    break;

                case 'K': // King
                    const kingMoves = [
                        [-1, -1], [-1, 0], [-1, 1],
                        [0, -1],           [0, 1],
                        [1, -1], [1, 0], [1, 1]
                    ];
                    kingMoves.forEach(([dr, dc]) => addMove(r + dr, c + dc));
                    break;
            }
            return moves;
        }

        /**
         * Filters pseudo-legal moves to ensure the King isn't left in check.
         */
        function getLegalChessMoves(sr, sc, currentBoard) {
            const pseudoLegalMoves = getPseudoLegalMoves(currentBoard, sr, sc);
            const legalMoves = [];
            const currentPlayerColor = getPieceColor(currentBoard[sr][sc]);

            for (const move of pseudoLegalMoves) {
                const tempBoard = JSON.parse(JSON.stringify(currentBoard));
                const movedPiece = tempBoard[sr][sc];

                tempBoard[move.r][move.c] = movedPiece;
                tempBoard[sr][sc] = null;

                if (!isKingInCheck(tempBoard, currentPlayerColor)) {
                    legalMoves.push(move);
                }
            }
            return legalMoves;
        }

        /**
         * Gets all legal moves for a player of a specific color on a given board.
         */
        function getAllLegalChessMoves(boardState, playerColor) {
            const allMoves = [];
            for (let r = 0; r < CHESS_BOARD_SIZE; r++) {
                for (let c = 0; c < CHESS_BOARD_SIZE; c++) {
                    const pieceCode = boardState[r][c];
                    if (pieceCode && getPieceColor(pieceCode) === playerColor) {
                        const legalMovesForPiece = getLegalChessMoves(r, c, boardState);
                        legalMovesForPiece.forEach(move => {
                            allMoves.push({ sr: r, sc: c, tr: move.r, tc: move.c });
                        });
                    }
                }
            }
            return allMoves;
        }

        /**
         * Implements basic AI logic for a bot player's Chess turn (LOCAL PLAY).
         */
        function chessBotTurnLocal() {
            const currentPlayer = chess.players[chess.currentPlayerIndex];
            const botColor = currentPlayer.id[0];
            updateChessStatus(`${currentPlayer.name} (Bot) is thinking...`);

            setTimeout(() => {
                const allPossibleMoves = getAllLegalChessMoves(chess.board, botColor);

                if (allPossibleMoves.length > 0) {
                    const randomMove = allPossibleMoves[Math.floor(Math.random() * allPossibleMoves.length)];
                    moveChessPieceLocal(randomMove.sr, randomMove.sc, randomMove.tr, randomMove.tc);
                } else {
                    if (isKingInCheck(chess.board, botColor)) {
                        updateChessStatus(`${currentPlayer.name} (Bot) is in CHECKMATE!`);
                    } else {
                        updateChessStatus(`${currentPlayer.name} (Bot) has no legal moves. STALEMATE!`);
                    }
                    chess.state = 'game_over';
                }
            }, 1500);
        }
    </script>
</body>
</html>